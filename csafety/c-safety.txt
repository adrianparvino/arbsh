C-Safety   An intermediate level guide for C programmers wishing to learn 
idiomatic C with pointers. Topics of safe boundary arithmetic and abstract data
structures are covered with example programs. Strategies for creating meaningful
checks and diagnostics to ensure reasonable levels of c safety have been
devised and incorporated into the examples.




(C) 2017 Christopher Michael Graff


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (programming with abstract objects 1.0)		page 1

The C standard identifies objects in a very broad sense and applies the
term to "any object in memory". However this definition of object does
not address the power that C has to create and use objects in a modern
sense of it being the primary predecessor to "object oriented
programing".

Presented below is a method of "programming with objects" in C.


        #include <stdlib.h>
        #include <stdio.h>
        #include <unistd.h>

        typedef struct{
                char *rp;
                size_t len;
        } object;

        int main(void)
        {
                size_t lim = 10;

                /* create an array of objects */
                object *p, *o;
                if (!(o = p = malloc(sizeof(object) * lim)))
                        return 1;

                /* allocate memory and populate array members */
                for (o=p; o-p < lim ; ++o)
                {
                        if (!(o->rp = malloc(sizeof(char) * 100)))
                                return 1;
                        o->len = snprintf(o->rp, 100, "string %zu\n", o-p);
                }

                /* test the array of objects (fast write!) */
                for (o=p; o-p < lim ; ++o)
                        write(1, o->rp, o->len);

                /* free the objects' member memory allocations */
                for (o=p; o-p < lim ; ++o)
                        free(o->rp);

                /* free the object */
                free(p);

                return 0;
        }


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Pass by address of a pointer to a pointer 2.0)	         page 2


C does not support "pass by reference" nonetheless by passing the value
of an address to a function which accepts a pointer to a pointer to a 
type we can modify a value in C similar to C++'s "pass by reference". 
The canonical example of this is getline() from the C standard library.

Presented below is the function pass_bappt() (Pass by address of a
pointer to a pointer to a type).


	#include <stdlib.h>
	#include <stdio.h>
        typedef struct{
                char *rp;
        } object;

        void does_not_work(char *a)
        {
                /* Doesn't work! */
                a = "Does not work!";
        }

        void pass_bappt(char **a)
        {
                *a = "hello world";
        }

        int main(void)
        {
                object *o;
                if(!(o = malloc(sizeof(object))))
                        return 1;
                o->rp = "Pointer to a string literal";
                printf("%s\n", o->rp);
                pass_bappt(&(o->rp)); /* note the '&' */
                printf("%s\n", o->rp);
                does_not_work(o->rp);  /* Doesn't work! (obviously) */
                printf("%s\n", o->rp);
                free(o);
                return 0;
        }

Note that this creates an "anti-pattern" within the C programming language.
Ideally values are saved using a different mechanism such as passing an object 
with mutable members to a function and then returning that object to the caller
(the calling function).  


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Prevent double frees 3.0)	   	              		page 3


The C11 draft states "If ptr is a null pointer, no action occurs."
therefore preventing "double frees" is reduced to the simple
operation of explicitly setting deallocated variables to NULL.  


	#include <stdlib.h>
	#include <stdio.h> 

	typedef struct{ 
	        char *rp; 
		size_t len;
	}object;

	void *safe_free(void *a) 
	{ 
		free(a); 
		return NULL; 
	}

	int main(void)
	{
		char *l; 
		object *o;
		o = malloc(sizeof(object));
		o->rp = malloc(1000); 
		o->rp = safe_free(o->rp);
		o->rp = safe_free(o->rp); // does nothing
		o = safe_free(o);
		o = safe_free(o); // does nothing

		return 0; 
	} 


-------------------------------------------------------------------------------
------------------------------------------------------------------------------- 
c-safety (Opaque objects and pointers 4.0)                               page 4

This program (main.c) attempts to use the opaque-objects we create.
It has the ability to access and use the type "object" but not its
structure members. The opaque object can only be manipulated via
its API. Which in this case are the simple functions object_init ..
and so on.

main.c:
	#include "shared.h"
	int main(void)
	{
		object *o;
		o = object_init(o);
		object_populate(o, "This is a string\n");
		object_write(o);
		object_free(o);

		//o->rp = "hello";  /* <-- This will fail to compile if it is a
				     truly opaque type, producing the error: 
				     "dereferencing pointer to incomplete type 
				     â€˜object {aka struct object}" thus proving 
			             that the implementation details are indeed 
				     hidden from the user of the API. Uncomment 
				     it to verify */
		return 0;
	}


Makefile:
	all:

		gcc -c opaque.c -o opaque.o
		gcc main-driver.c opaque.o -o main-driver

	clean:

		rm *.o
		rm main-driver



Presented here (in opaque.c) is the actual opaque API library implementation. 
We declare an instantiation of the primary API structure from "shared.h" our 
shared header. But in this version we actually define its members. Inside of
this file we can access all of the members of our opaque type but the end user 
of the API, or indeed anyone outside of this file can not.  However, they can 
use the library as a library of opaque objects. The canonical example of the 
opaque object in C is the FILE * structure from stdio.  


opaque.c :
	#include <stdlib.h>
	#include <stdio.h>
	#include <unistd.h>
	#include <string.h>
	#include "shared.h"


	struct object {
		char *rp;
		size_t len;
	}; 

	size_t object_size(void)
	{
		return sizeof(object);
	}

	object *object_init(object *o)
	{
		o = malloc (object_size());
		o->len = 0;
		return o;
	}

	object *object_populate(object *o, char *s)
	{
		o->rp = s;
		o->len = strlen(s);
	}

	void object_free(object *o)
	{ 
		free(o);
	}

	void object_write(object *o)
	{
		write(1, o->rp, o->len);
	}


shared.h:
	#include <stddef.h>

	typedef struct object object; 
	size_t object_size(void); 
	object *object_init(object *);
	object *object_populate(object *, char *);
	void object_write(object *);
	void object_free(object *); 


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Creating static libraries with ar 5.0)                         page 5

ar has been around for a long time. and it makes very simple archives. These
very simple archives happen to be readable by the compiler and we can
concatenate object code more or less endlessly into one of these .a and then
use it as a "library". Another type of library is called a dynamic library and
they end with .so.

Static libraries get the entire archive of object code linked into the executable.
Conversely, dynamic libraries sit in /lib and are loaded at runtime. Static 
binaries will work in a chroot with no other libs at all. However, they may still
have other dependencies such as /proc or the terminfo database.


Makefile:
	all: 

		# create the object code
		gcc -c frog.c dog.c swan.c -static
		# Here we use `ar' to create the static library "libanimals.a"
		ar -cvq libanimals.a frog.o dog.o swan.o 
		# And finally link it into our executable test driver "main.c"
		gcc main.c libanimals.a -o main -static

	clean:

		rm frog.o dog.o swan.o libanimals.a main

dog.c:
	int dogs = 10;

	int inc_dogs(int d)
	{
		return d + 1;
	}

frog.c:
	int frogs = 10;

	int inc_frogs(int d)
	{
		return d + 1;
	}

swan.c:
	int swans = 10;

	int inc_swans(int d)
	{
		return d + 1;
	}

main.c:
	#include <stdio.h>
	#include "animals.h"
	int main(void)
	{ 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs);
		dogs = inc_dogs(dogs);
		swans = inc_dogs(swans);
		frogs = inc_dogs(frogs); 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs); 
		return 0; 
	}

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Safe multiplication 6.0)		                         page 6


The C standard specifies that unsigned integer types must wrap around
when they hit their maximum limit. However it is possible to keep this
from happening by carefully precomputing each calculation to see that
it can fit. The limit of a given size is computed with (T)-1. Presented 
below is an idea for safe bounded multiplication.
	

	#include <stdio.h>
	size_t safe_multiply(size_t i, size_t x, size_t lim)
	{
		if (i == 0) /* Handle zero */
			return 0;
		if (lim / i >= x ) 
		{
			fprintf(stderr, "Muliplication proposal accepted\n");
			return i * x;
		}
		fprintf(stderr, "Muliplication proposal rejected\n");
		return lim;
	}

	int main(void)
	{
		size_t a = (size_t) -1; 
		a = safe_multiply(a, 123123, (size_t) -1); 
		printf("%zu\n", a);
	
		a = (size_t) -1 / 10;
		a = safe_multiply(a, 123123, (size_t) -1);
		printf("%zu\n", a);

		unsigned int b = (unsigned int) -1;
		b = safe_multiply(b, 123123, (unsigned int) -1);
		printf("%u\n", b); 
	
		b = 500;
		b = safe_multiply(b, 1000000, (unsigned int) -1);
		printf("%u\n", b);
		
		b = (unsigned int) -1;
		b = safe_multiply(b, b - 123, (unsigned int) -1);
		printf("%u\n", b);

		return 0;
	} 


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Eliminating concern for dangling pointers 7.0)                 page 7

Dangling pointers can be completely avoided in C by keeping an extra copy of
the original pointer. The idiom might be "a = b = malloc(..)" as opposed to
"a = malloc(..)". In this way we always have access to the original pointer
location and can free it without error. Presented below is a short program that 
creates a dangling pointer but then uses a copy to the original pointer it had 
saved to free it.


        #include <stdlib.h>
        #include <stdio.h>
        #include <unistd.h>

        int main(void)
        {
                char *a, *b;
                const char *string = "This is a string\n";

                a = b = malloc(32); // keep an extra copy
                while (*string)
                        *b++ = *string++; // "b" is now a dangling pointer 
                write(1, a, b - a);

                free(a); // "a" however, still points to the original location 
                return 0;
        }


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Function pointers 8.0) 			                 page 8

Function pointers make objects even more powerful by allowing them to have
functions assigned to their members. Effectively they take the struct which is 
data and the function (which has functionality) and combines them. Thus allowing
the object itself to perform actions.


	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h> 

	typedef struct{ 
	        char *rp;
		size_t len;
		int (*f)(int, int);
	} object;

	int add(int x, int y)
	{
		return x+y;
	}

	int mul(int x, int y)
	{
		return x*y;
	}

	object *object_init(object *o, int (*func)(int x, int y))
	{
		o->f = func;
		return o;
	}

	object *object_exec(object *o, int x, int y)
	{ 
		printf( "%d\n",  o->f(x, y));
		return o;
	}

	int main(void)
	{ 
		object *o = malloc(sizeof(object));

		o = object_init(o, add);

		o = object_exec(o, 2, 3);

		o = object_init(o, mul);

		o = object_exec(o, 2, 3);

			/* or */

		printf( "%d\n",  o->f(3, 3));

		free(o);

		return 0;
	} 

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Function pointers (arrays of) 8.1) 		                 page 9

The concept of function pointers can be extended to an array of function
pointers within an object. By also including an "iterator" function we can
effectively add functions into the array one at a time and then execute them
all at once with the iterator function. The initializer function is left
separate and functions are added with the obj_addaction function. Presented
below is a program that demonstrates how to create a powerful object using an 
array of function pointers

	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h> 

	typedef struct object object;

	object *iterate(object *o);

	typedef struct object{ 
	        char *rp;
		size_t len;
		size_t actions;
		object *(*iterate)(object *o); 
		object *(*f[10])(object *o); 
	} object;

	object *obj_init(object *o)
	{
		o->iterate = iterate;
		o->rp = malloc(256);
		o->len = 0;
		o->actions = 0;
	}

	object *obj_pop(object *o)
	{
		o->len = sprintf(o->rp, "%s\n", "string here");
	}

	object *obj_write(object *o)
	{
		write(1, o->rp, o->len);
	}

	object *obj_addaction(object *o, object *(*f)(object *))
	{
		o->f[o->actions] = f;
		o->actions++;
		return o;
	}

	object *iterate(object *o)
	{
		size_t i = 0;
		for (; i < o->actions;++i) 
			o->f[i](o);
		return o;
	}

	int main(void)
	{ 
		object *o = malloc(sizeof(object));
		o = obj_init(o);
		o = obj_addaction(o, obj_pop);
		o = obj_addaction(o, obj_write);
		o = o->iterate(o);
		return 0;
	}


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Creating dynamic libraries 9.0) 		                page 10

Unlike static libraries, dynamic libraries can not be made using the `ar'
utility and instead must be constructed by supplying directions to the compiler
telling it to create them. Because our dynamic library is not going to be
installed we also have to specify the "-rpath" so that the dynamic loader knows
how to find the executable. Normally with a library that will be installed to
the end target of a system's /lib directory "-rpath" should not be specified.
Another way to do this is to not use "rpath" at all and instead execute the
test binary in place like this `LD_LIBRARY_PATH=$(pwd) ./main'. Presented below
are 5 files that can be put into a directory to create a simple dynamic library
and build system.

Makefile:

	all: 

		# Create the object code
		gcc -c frog.c dog.c swan.c -static
		# Create a dynamic library
		cc -shared -Wl,-soname,libanim.so -o libanim.so frog.o swan.o dog.o
		# And finally link it into our executable test driver "main.c"
		gcc main.c libanim.so -o main "-Wl,-rpath=$(PWD)"

	clean:

		rm frog.o dog.o swan.o libanim.so main


animals.h:

	#ifndef _ANIMALS_
	#define _ANIMALS_

	extern int dogs;
	extern int swans;
	extern int frogs;
	int inc_dogs(int);
	int inc_swans(int);
	int inc_frogs(int);

	#endif

frog.c:
	int frogs = 10;

	int inc_frogs(int d)
	{
		return d + 1;
	}
dog.c:
	int dogs = 10;

	int inc_dogs(int d)
	{
		return d + 1;
	
	}
swan.c:
	int swans = 10;

	int inc_swans(int d)
	{
		return d + 1;
	}
main.c
	#include <stdio.h>
	#include "animals.h"
	int main(void)
	{ 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs);
		dogs = inc_dogs(dogs);
		swans = inc_dogs(swans);
		frogs = inc_dogs(frogs); 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs); 
		return 0; 
	} 


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Simple objects using typedefed structs 10.0)                  page 13


It's possible to program using objects in C without all of the complicated
pointer foo-bar. Here is an example of how to program in C using only simple 
arrays of typedefed structs.

        #include <stdlib.h>
        #include <stdio.h>
        #include <unistd.h>

        typedef struct{
                char rp[1024];
                size_t len;
        } object;

        int main(void)
        {
                size_t i = 0;
                size_t lim = 10;
                object p[10];
                object *o = p;

                for (o=p; i < lim ; ++i, ++o)
                        o->len = sprintf(o->rp, "string %zu\n", i);

                for (i=0, o=p; i < lim ; ++i, ++o)
                        write(1, o->rp, o->len);

                return 0;
        }


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Unix pipelines (for a simple shell) 11.0)                     page 14
/*
Unix pipelines can be created between utilities without using a buffer of any
kind. Using the typical object it becomes simple to store the information
needed to seamlessly connect the stdin and stdout of a series of utilities.
Pipe() is not set up for the final command in the sequence. Presented below is
a small program that demonstrates the basics needed for writing a simple shell
that supports arbitrary numbers of pipes. The sequence used is equivalent to
"ls -l | wc -l | wc -l | wc -l | wc -l > outfile"
*/

        #include <stdlib.h>
        #include <stdio.h>
        #include <unistd.h>
        #include <sys/types.h>
        #include <sys/wait.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>

        typedef struct{
                char *cmd[3];   /* command vector */
                int in;         /* stdin */
                int out;        /* stdout */
                pid_t pids;     /* for waitpid */
                int err;        /* for waitpid */
                int piped;      /* boolean value */
                char *infp;
                char *outfp;
                int outflags;
                int boole;
        } object;

        object *piped(object *o)
        {
                int fildes[2];
                if ((pipe(fildes)) == -1)
                        return NULL;
                (o+1)->in = fildes[0];
                o->out = fildes[1];
                return o;
        }

        object *child(object *o)
        {
                dup2(o->in, STDIN_FILENO);
                dup2(o->out, STDOUT_FILENO);
                execvp(o->cmd[0], o->cmd);
                _exit(1);
                return o;
        }
        object *foreground(object *o)
        {
                waitpid(o->pids, &(o->err), 0);
                if (o->out != -1)
                        close(o->out);
                if (o->in != -1)
                        close(o->in);
                return o;
        }

        object *execute(object *o)
        {
                if ( o->infp != NULL )                  /* < */
                        if((o->in = open(o->infp, O_RDONLY)) == -1)
                                return NULL;
                if (o->outfp != NULL )                  /* >, >> */
                        if((o->out = open(o->outfp, o->outflags, 0755)) == -1)
                                return NULL;
                if (o->piped == 1)                      /* | */
                        if(!(o = piped(o)))
                                return NULL;
                if ((o->pids = fork()) == 0)
                        o = child(o);
                o = foreground(o);
                return o;
        }

        int main(void)
        {
                size_t i = 0;
                object p[10] = 
		{{{ "ls", "-l", NULL}, -1, -1, 0, 0, 1,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 0 ,NULL, 
		"outfile", O_APPEND|O_RDWR|O_CREAT, -1}};

                object *o = p;

                for (;i<10;o++,++i)
                {
                        if (i && (o-1)->err == 0 && (o-1)->boole == 1)  /* || */
                                continue;
                        if (i && (o-1)->err != 0 && (o-1)->boole == 0)  /* && */
                                continue;
                        o = execute(o);
                }

                return 0;
        }



-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Unsigned pow 12.0 (base^cardinality))                         page 15


The total number of values possible within a given range in base N within a set
with a cardinality of C can be expressed as (N^C).

N=2
C=4

scientfic
notation   decimal    binary

2^4    =   16    =    0000 (1)  0100 (5)  1000 (9)   1100 (13)
                      0001 (2)  0101 (6)  1001 (10)  1101 (14)
                      0010 (3)  0110 (7)  1010 (11)  1110 (15)
                      0011 (4)  0111 (8)  1011 (12)  1111 (16)
                 

Using binary counting it is easy to prove this formula by iterating through all
possible values. In decimal (greater N) or with a greater cardinality (greater 
C) the table of values would be much larger --however the formula for computing
the total amount of unique values the number can hold is the same.

This formula (N^C) allows for fast and logical computation of probabilities in
a non-deterministic setting such as a dice game throwing "random" dice throws.

Here is an explanation of the probability of obtaining the sequence
 4, 6, 2, 5, 7, 9, 8 out of a random throwing of 7 dice: 

6 sided dice use a base 5 counting system consisting of the character values 1-6
(1,2,3,4,5 and 6). Therefore computing the maximum number of possible dice
combinations in base 5 using 7 dice is simple and can be expressed as the value 
5555555 (or 6666666). Therefore the entire range of this number system sits
between 0000000 and 5555555 possibilities in base 5. The possibility of such a
a roll is therefore 1/(5^7).

Normally '^' powers in C are computed using pow() from libm and the math.h
header. However because we are going to use size_t in this case to represent our
counting base pow() itself is unsuitable. The function usign_pow presented below
is sufficient for calculating base*cardinality which is never negative nor
consisting of fractional parts. (support for fractions in pow requires exp and
log and is not covered here).


        #include <stdio.h>

        size_t safe_division(size_t i, size_t x)
        {
                if (i==0)
                {
                        fprintf(stderr, "Divide by zero forced to return 0\n");
                        return 0;
                }
                return i / x;
        }

        size_t safe_multiply(size_t i, size_t x, size_t lim)
        {
                size_t tmp = safe_division(lim, i);
                if (tmp >= x)
                {
                        fprintf(stderr, "Muliplication proposal accepted\n");
                        return i * x;
                }else if (tmp == 0)
                        return 0;
                fprintf(stderr, "Muliplication proposal rejected\n");
                return lim;
        }

        size_t safe_upow(size_t x, size_t n)
        {
                size_t y = 1;
                while (n--)
                        y = safe_multiply(y, x, (size_t)-1);
                return y;
        }

        int main(void)
        {
                size_t base = 2;
                size_t cardinality = 128;
                printf("total range of brute elements %zu\n", safe_upow(base, cardinality));
                return 0;
        }

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Singly linked lists (13.0))                                   page 16

Singly linked lists can be created such that the ->next members point in either
direction. The simplest possible singly linked list builds this chain backwards
sometimes leading people to believe that it needs to be reversed. Such reversal
is unneeded as the linked list can be simply created going the opposite
direction. Presented below are the functions forpop and backpop which create a
forward and backward populated linked list respectively.


	#include <stdio.h>
	#include <stdlib.h>

	typedef struct object{ 
		size_t i;
		struct object *next;
	} object;

	object *freeobj(object*);

	void *safe_free(void *a)
	{
	        free(a);
	        return NULL;
	}

	void *verbose_malloc(size_t i)
	{
		void *ret;
		if (!(ret = malloc(i))) 
			perror("malloc error: ");
		return ret;
	}

	object *forpop(object *head, size_t i)
	{
		/* modified linked list shares members forwards */
	        static object *tail = NULL;
	        object *ptr;
		if(!(ptr = verbose_malloc(sizeof(object))))
			return head = freeobj(head);

	        ptr->next = NULL;
	        ptr->i = i;
	        if (!(head))
	                tail = head = ptr;
	        else if (tail){
	                tail->next = ptr;
	                tail = ptr;
	        }
	        return head;
	}

	object *backpop(object *head, size_t i)
	{
		/* simple linked list shares members backwards */
		object* o;
		if (!(o = verbose_malloc(sizeof(object))))
			return head = freeobj(head);
		o->i = i;
		o->next = head;
		return o;
	}

	void iterate(object* head)
	{
		object *o;
		for(o = head;o;o = o->next) 
			printf("(%zu)-->", o->i); 
		printf("END\n\n");
	}

	object *placefreeobj(object *hold)
	{
		if (hold)
	        {
	                printf("free(%zu)-->", hold->i);
	                hold = safe_free(hold);
	        }
		return hold;
	}

	object *freeobj(object *head)
	{
	        object *o;
		object *hold = NULL;
	        for(o = head;o;o = o->next)
		{
			hold = placefreeobj(hold);
			hold = o; 
		}
		hold = placefreeobj(hold);
	
		if (o == head)
			printf("Nothing to be freed  ");
	        printf("END\n\n");
		return hold;
	}

	int main(void)
	{ 
		size_t i;
		object* head = NULL; 
		for(i = 0; i<=20; i++) 
			if (!(head = forpop(head, i)))
				return 1;
	
		iterate(head);
		head = freeobj(head);
	
		for(i = 0; i<=20; i++) 
			if (!(head = backpop(head, i)))
				return 1;
	
		iterate(head);
		head = freeobj(head);

		return 0;
	} 

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Safe reallocation)                                            page 17

There are very few tricks that universally apply to all C memory management. By
using the idiom of passing the value of a pointer to a pointer to a type to a
wrapper for free, realloc and malloc however, one can force a number of useful
scenarios. One such scenario is to take advantage of the C standard's specified
behavior for realloc; "If memory for the new object cannot be allocated, the 
old object is not deallocated and its value is unchanged" in the C11 draft.
We can therefore reduce this operation to a single line of code using a wrapper
function. Similarly, all freed memory can be explicitly made to point to NULL
. Malloc in this case performs no special function but is wrapped in the same
way as free and realloc in order to present a consistent API.

	#include <stdio.h>
	#include <stdlib.h>

	int safe_free(void **a)
	{ 
		free(*a);
		*a = NULL;
		return 1;
	}

	int safe_realloc(void **a, size_t i)
	{
		void *tmp;
		if (!(tmp = realloc(*a, i)))
		{
			perror("Realloc error: ");
			return -1;
		}
		*a = tmp;
		return 1;
	}

	int safe_malloc(void **a, size_t i)
	{ 
	        if (!(*a = malloc(i)))
	        {
	                perror("Malloc error: ");
	                return -1;
	        }
		return 1;
	}

	int main(void)
	{
		char *a;
		size_t i = 0;
		if (!(safe_malloc((void**)&a, 1)))
			return 1; 
		if (!(safe_realloc((void**)&a, 10)))
			return 1; 
		if (a)
			printf("a  exists\n"); 
		for (i=0;i < 10;++i)
			a[i];
		printf("First reallocation successful\n");
		if (!(safe_realloc((void**)&a, (size_t)-1))) // will fail
			;//return 1
		if (a) printf("a  exists\n");
		for (i=0;i < 10;++i)
			a[i];
		printf("Second reallocation left the pointer unchanged\n");
		if(!(safe_free((void**)&a)))
			;// NULL pointers passed to free indicate design flaw 
		return 0;
	}


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Doubly linked list)                                           page 18

A doubly linked list is a data structure of nodes linked together in both
directions. These node creation and traversal directions are accessed with the
structure members "prev" and "next". NULL is used for the linked list terminal
end points.

[x] = prev <-[o]
             [o]->next = [o]
             [o] = prev<-[o]
                         [o]->next = [o]
                         [o] = prev<-[o]
                                     [o]->next = [o]
                                     [o] = prev<-[o] 
                                                 [o]->next = [o]
                                                 [o] = prev<-[o]
                                                             [o]->next = [x]

Here is a program to implement a basic doubly linked list with node insertion
and deletion;

	#include <stdio.h>
	#include <stdlib.h>

	typedef struct object {
		size_t i;
		struct object *prev;
		struct object *next;
	} object;

	object *initlist(size_t);

	size_t objectsize(void)
	{
		return sizeof(object);
	}

	void *safe_free(void *a)
	{
	        free(a);
	        return NULL;
	}

	void *verbose_malloc(size_t i)
	{
	        void *ret;
	        if (!(ret = malloc(i)))
	                perror("malloc error: ");
	        return ret;
	}

	object *insertnode(object *o, size_t i)
	{ 
		object *ptr = initlist(i);
		ptr->prev = o;
		ptr->next = o->next;
		o->next->prev = ptr;
		o->next = ptr; 
		return ptr;
	}
	
	object *deletenode(object *o)
	{ 
		object *tmp = o->prev;
		o->prev->next = o->next;
		o->next->prev = o->prev; 
		o = safe_free(o); 
		return tmp;
	}
	
	object *initlist(size_t i)
	{ 
		object *o = verbose_malloc(objectsize()); 
		if (!(o))
			return NULL; 
	        o->i = i;
	        o->prev = o->next = NULL; /* terminal NODES */
		return o;
	}
	
	object *delhead(object *o)
	{ 
	        object *tmp = o->next;
	        o->next->prev = NULL; 
	        o = safe_free(o);
	        return tmp;
	}
	
	object *deltail(object *o)
	{ 
	        object *tmp = o->prev;
	        o->prev->next = NULL; 
	        o = safe_free(o);
	        return tmp;
	}
	
	object *addhead(object *o, size_t i)
	{ 
		object *ptr = initlist(i); 
		ptr->next = o;
		o->prev = ptr;
		return ptr;
	} 
	
	object *addtail(object *o, size_t i)
	{
		object *ptr = initlist(i); 
		ptr->prev = o;
		o->next = ptr;
		return ptr;
	} 
	
	void listbackward(object *ptr)
	{ 
		for(;ptr;ptr = ptr->prev)
			printf("%zu ", ptr->i); 
		printf("\n\n");
	}
	
	void listforward(object *ptr)
	{
		for(;ptr;ptr = ptr->next)
			printf("%zu ", ptr->i);
		printf("\n\n");
	}
	
	object *placefreeobj(object *hold)
	{
	        if (hold) 
	        	printf("free(%zu)--> ", hold->i);
	        return safe_free(hold);
	}
	
	object *freeobj(object *head)
	{
	        object *o;
	        object *hold = NULL;
	        for(o = head;o;o = o->next)
	        {
	                hold = placefreeobj(hold);
	                hold = o;
	        }
	        hold = placefreeobj(hold);
	
	        if (o == head)
	                printf("Nothing to be freed  ");
	        printf("END\n\n");
	        return hold;
	}
	
	int main(void)
	{
		size_t i = 0; 
		object *head = NULL;
		object *tail = NULL;
		object *o;
	
		/* create */
		tail = head = initlist(i);
	
		/* add to tail */
		for (i =1; i <= 20; i++) 
			tail = addtail(tail, i); 
		listforward(head);
		listbackward(tail);
	
		/* add to head */
		for (i=30; i <= 40; i++)
			head = addhead(head, i); 
		listforward(head);
		listbackward(tail); 
		
		/* node deletion */
	        for(i=0,o = head;o;o = o->next,++i)
	                if (i >3 && i < 13)
				o = deletenode(o); 
		listforward(head);
		listbackward(tail); 
	
		/* node insertion */
	        for(i=0,o = head;o;o = o->next,++i)
	                if (i >3 && i < 13)
				o = insertnode(o, i);
		
		listforward(head);
		listbackward(tail);
	
		/* delete from head */
		head = delhead(head);
		head = delhead(head);
	
		/* delete from tail */
		tail = deltail(tail);
		tail = deltail(tail);
		
		listforward(head);
		listbackward(tail);
	
		/* free the list and NULL the root and tail nodes */
		tail = head = freeobj(head); 
		return 0; 
	}


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Tries, R-way trie)                                            page 19

Retrieval trees (tries) offer 0(N) time complexity on lookup operations. Tries 
have the unique property of aborting upon an "early miss", which greatly 
increases their effectiveness.  

        "Proposition G. The number of array accesses when 
         searching in a trie or inserting a key into a trie
         is at most 1 plus the length of the key." 
                 (Sedgewick, "Algorithms" 4th ed. pg730)


Typically in depictions of tries NULL nodes are not shown, as is the case in
the depiction below:


             [root]                   andy
          /          \                android
       [a]            [b]             androids
        |              |              andrew
       [n]            [a]             androgen
        |  \           |              ant
       [d] [t]        [r]
     /  |              |  \           barnacle
   [y] [r]            [r] [n]         barney
        |  \           |   |  \       barry
       [e] [o]        [y] [a] [e]
        |   | \            |   |
       [w] [i] [g]        [c] [y]
            |   |          |
           [d] [e]        [l]
         /      |          |
       [s]     [n]        [e]

A trie carries no data in the structure members of its nodes. Instead, the data
is implied by mapping an element of the key to a node thus rendering the node
no longer NULL.


The program below presents an R-way trie. Insertion, deletion, searching,
printing and histogram functions are supplied.


	#include <stdio.h>
	#include <stdlib.h> 
	#include <string.h>
	
	/* map all ASCII values to an indice */
	size_t alphasize = 128;
	
	typedef struct object {
		int leaf; 
		struct object **children; 
	}object;
	
	int trie_isfreenode(object *o)
	{
	        size_t i;
	        for(i = 0; i < alphasize; i++) 
	                if(o->children[i])
	                        return 0;
	        return 1;
	}
	
	int _trie_nodel(object *o, char *key, size_t level)
	{ 
	        size_t index;
	        if(!(o))
	   		return 0;
	        if(key[level] == 0)
	        {
	                if(o->leaf)
	                {
	                        o->leaf = 0;
	                        if(trie_isfreenode(o))
	                                return 1; 
	                }
			return 0;
	        } 
	
	        index = key[level];
	        if(_trie_nodel(o->children[index], key, level+1))
	        {
	                free(o->children[index]);
	                o->children[index] = NULL;
	                return (!o->leaf && trie_isfreenode(o));
	        } 
	        return 0;
	}
	
	int trie_nodel(object *o, char *key)
	{
		size_t level = 0;
		_trie_nodel(o, key, level);
	}
	
	object *trie_init(void)
	{
		size_t i = 0; 
		object *o = malloc(sizeof(object)); 
		if (!(o))
			return NULL;
		o->leaf = 0;
		if (!(o->children = malloc(sizeof(object) * alphasize)))
			return NULL;
		for (i = 0; i < alphasize; i++) 
			o->children[i] = NULL; 
		return o;
	} 
	
	void trie_insert(object *o, const char *pat)
	{
		size_t i; 
		size_t ind; 
		for (i = 0; pat[i]; i++)
		{
			ind = pat[i]; 
			if (!o->children[ind])
				o->children[ind] = trie_init(); 
			o = o->children[ind];
		}
		o->leaf = 1;
	} 
	
	int trie_search(object *o, const char *pat)
	{
		size_t i;
		size_t ind; 
		for (i = 0; pat[i]; i++)
		{
			ind = pat[i];
			if (!o->children[ind])
				return 0; 
			o = o->children[ind];
		} 
		if ( o != NULL && o->leaf)
			return 1;
		return 0; 
	} 
	
	void trie_free(object* root)
	{ 
		size_t i;
		for (i = 0; i < alphasize; i++)
		{
			if (root->children[i])
				trie_free(root->children[i]);
		}
		free(root->children);
		free(root);
	}
	
	void _trie_histogram(object* root, size_t level)
	{ 
		size_t i; 
		static char str[100]; 
	
		if (root->leaf)
		{
			str[level] = '\0';
			printf("\t\t\t    -->(%s)\n|", str); 
		} 
	 
		for (i = 0; i < alphasize; i++)
		{ 
			if (root->children[i])
			{
				printf("-%c", (int)i);
				str[level] = i; 
				_trie_histogram(root->children[i], level + 1);
			}
		}
	}
	
	void trie_histogram(object* root)
	{
		printf("root\n|\n|\n|");
		_trie_histogram(root, 0);
	}
	
	void _trie_display(object* root, size_t level)
	{ 
		size_t i; 
		static char str[100]; 
	
		if (root->leaf)
		{
			str[level] = '\0';
			printf("%s\n", str); 
		} 
	    
		for (i = 0; i < alphasize; i++)
		{ 
			if (root->children[i])
			{ 
				str[level] = i; 
				_trie_display(root->children[i], level + 1);
			}
		}
	}
	
	void trie_display(object* root)
	{
		size_t level = 0;
		_trie_display(root, level);
	}
	
	int main(void)
	{ 
		size_t i;
		char patterns[][10] = {"The!", "the", "there", "answer",
		 "any", "by", "bye", "th@eir", "123", "~~~", "zzzzz"}; 
		char queries[][10] = {"The!", "thaw", "th@eir", "these",
		 "123", "~~~", "zzzzz", "th"};
	
		object *root = trie_init(); 
	
		for (i=0; i < sizeof(patterns)/sizeof(patterns[0]); ++i)
			trie_insert(root, patterns[i]); 
		for (i=0; i < sizeof(queries)/sizeof(queries[0]); ++i)
		{ 
	                if (!(trie_search(root, queries[i])))
				printf("%s  -- Not found\n", queries[i]);
			else
				printf("%s  -- Found\n", queries[i]);
		}
		
		trie_display(root);
		trie_nodel((root), patterns[1]);
		printf("\n");
		trie_display(root);
		printf("\n");
		trie_histogram(root);
		trie_free(root);
		return 0;
	}

