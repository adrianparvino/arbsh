C-Safety   An intermediate level guide for C programmers wishing to learn 
idiomatic C with pointers.  Topics of safe boundary arithmetic and abstract data
structures are covered with example programs. Strategies for creating meaningful
checks and diagnostics to ensure reasonable levels of c safety have been
devised and incorporated into the examples.




(C) 2017 Christopher Michael Graff






-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (programming with abstract objects 1.0)		page 1

Though C does not support OOP constructions explicitly it does "permit OOP" in
the form of "object oriented patterns".  The C standard identifies objects in a
very broad sense and applies the term to any region of memory used for data
storage;

	"3.15 object [...] region of data storage in the execution 
	environment, the contents of which can represent value". (C11 draft)

However this definition of an "object" does not address the power that C has to
create and use objects in a modern sense of it being the primary predecessor of
"object oriented programing".

Presented below is a method of "programming with objects" in C.



	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h>
	#include <stddef.h>

	typedef struct{ 
	        char *rp; 
		size_t len;
	} object; 

	int main(void)
	{
		ptrdiff_t lim = 10;
	
		/* create a group or "array" of objects */
		object *p, *o;
		if (!(o = p = malloc(sizeof(object) * lim)))
			return 1;

		/* allocate memory and populate the group's members */
		for (o=p; o-p < lim ; ++o)
		{
			if (!(o->rp = malloc(sizeof(char) * 100)))
				return 1;
			o->len = snprintf(o->rp, 100, "string %zu\n", o-p); 
		} 

		/* test the group or "array" of objects (fast write!) */
		for (o=p; o-p < lim ; ++o)
			write(1, o->rp, o->len);

		/* free the objects' member memory allocations */
		for (o=p; o-p < lim ; ++o)
	                free(o->rp);

		/* free the object */
		free(p);

		return 0; 
	}


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Pass by address of a pointer to a pointer 2.0)	         page 2


C does not support "pass by reference". Nonetheless, by passing the value of an
address to a function which accepts a pointer to a pointer to a type we can 
modify a value in C similar to C++'s "pass by reference".  The canonical
example of this is getline() from the C standard library.

Presented below is the function pass_bappt() (Pass by address of a pointer to a
pointer to a type).


	#include <stdlib.h>
	#include <stdio.h>
        typedef struct{
                char *rp;
        } object;

        void does_not_work(char *a)
        {
                /* Doesn't work! */
                a = "Does not work!";
        }

        void pass_bappt(char **a)
        {
                *a = "hello world";
        }

        int main(void)
        {
                object *o;
                if(!(o = malloc(sizeof(object))))
                        return 1;
                o->rp = "Pointer to a string literal";
                printf("%s\n", o->rp);
                pass_bappt(&(o->rp)); /* note the '&' */
                printf("%s\n", o->rp);
                does_not_work(o->rp);  /* Doesn't work! (obviously) */
                printf("%s\n", o->rp);
                free(o);
                return 0;
        }

Note that this creates an "anti-pattern" within the C programming language.
Ideally values are saved using a different mechanism such as passing an object 
with mutable members to a function and then returning that object to the caller
(the calling function).  


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Prevent double frees 3.0)	   	              		page 3


The C11 draft states "If ptr is a null pointer, no action occurs." therefore 
preventing "double frees" is reduced to the simple operation of explicitly 
setting deallocated variables to NULL.  


	#include <stdlib.h>
	#include <stdio.h> 

	typedef struct{ 
	        char *rp; 
		size_t len;
	}object;

	void *safe_free(void *a) 
	{ 
		free(a); 
		return NULL; 
	}

	int main(void)
	{
		char *l; 
		object *o;
		o = malloc(sizeof(object));
		o->rp = malloc(1000); 
		o->rp = safe_free(o->rp);
		o->rp = safe_free(o->rp); // does nothing
		o = safe_free(o);
		o = safe_free(o); // does nothing

		return 0; 
	} 


-------------------------------------------------------------------------------
------------------------------------------------------------------------------- 
c-safety (Opaque objects and pointers 4.0)                               page 4

This program (main.c) attempts to use the opaque-objects we create.  It has the
ability to access and use the type "object" but not its structure members. The
opaque object can only be manipulated via its API. Which in this case are the
simple functions object_init ..  and so on.

main.c:
	#include "shared.h"
	int main(void)
	{
		object *o;
		o = object_init(o);
		object_populate(o, "This is a string\n");
		object_write(o);
		object_free(o);

		//o->rp = "hello";  /* <-- This will fail to compile if it is a
				     truly opaque type, producing the error: 
				     "dereferencing pointer to incomplete type 
				     â€˜object {aka struct object}" thus proving 
			             that the implementation details are indeed 
				     hidden from the user of the API. Uncomment 
				     it to verify */
		return 0;
	}


Makefile:
	all:

		gcc -c opaque.c -o opaque.o
		gcc main-driver.c opaque.o -o main-driver

	clean:

		rm *.o
		rm main-driver



Presented here (in opaque.c) is the actual opaque API library implementation. 
We declare an instantiation of the primary API structure from "shared.h" our 
shared header. But in this version we actually define its members. Inside of
this file we can access all of the members of our opaque type but the end user 
of the API, or indeed anyone outside of this file can not.  However, they can 
use the library as a library of opaque objects. The canonical example of the 
opaque object in C is the FILE * structure from stdio.  


opaque.c :
	#include <stdlib.h>
	#include <stdio.h>
	#include <unistd.h>
	#include <string.h>
	#include "shared.h"


	struct object {
		char *rp;
		size_t len;
	}; 

	size_t object_size(void)
	{
		return sizeof(object);
	}

	object *object_init(object *o)
	{
		o = malloc (object_size());
		o->len = 0;
		return o;
	}

	object *object_populate(object *o, char *s)
	{
		o->rp = s;
		o->len = strlen(s);
	}

	void object_free(object *o)
	{ 
		free(o);
	}

	void object_write(object *o)
	{
		write(1, o->rp, o->len);
	}


shared.h:
	#include <stddef.h>

	typedef struct object object; 
	size_t object_size(void); 
	object *object_init(object *);
	object *object_populate(object *, char *);
	void object_write(object *);
	void object_free(object *); 


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Creating static libraries with ar 5.0)                         page 5

Ar, is a POSIX specified archiving utility. The simple archives it creates are 
readable by the compiler and can be used to store object code. The static 
libraries made by `ar' end with a ".a". If the library's name is "foo" then the 
resulting static library should be called libfoo.a.  

Static libraries get the entire archive of object code linked into the 
executable.  Conversely, dynamic libraries (which end in .o) are loaded at 
runtime. Static binaries will work in a chroot with no other libraries at all. 
However, they may still have other dependencies such as /proc or the terminfo 
database. Put the following six files into their own directories and invoke
`make' to create the example static library libanimals.a



dog.c:

	int dogs = 10;
	
	int inc_dogs(int d)
	{
		return d + 1;
	}

frog.c:

	int frogs = 10;
	
	int inc_frogs(int d)
	{
		return d + 1;
	}

swan.c:

	int swans = 10;
	
	int inc_swans(int d)
	{
		return d + 1;
	}

animals.h:

	#ifndef _ANIMALS_
	#define _ANIMALS_
	
	extern int dogs;
	extern int swans;
	extern int frogs;
	int inc_dogs(int);
	int inc_swans(int);
	int inc_frogs(int);
	
	#endif
	
main.c:

	#include <stdio.h>
	#include "animals.h"
	int main(void)
	{ 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs);
		dogs = inc_dogs(dogs);
		swans = inc_swans(swans);
		frogs = inc_frogs(frogs); 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs); 
		return 0; 
	}

Makefile:

	
	all: 
	
		# create the object code
		gcc -c frog.c dog.c swan.c -static
		# Here we use `ar' to create the static library "libanimals.a"
		ar -cvq libanimals.a frog.o dog.o swan.o 
		# And finally link it into our executable test driver "main.c"
		gcc main.c libanimals.a -o main -static 
	
	clean:
	
		rm frog.o dog.o swan.o libanimals.a main
	


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (6.0)		                         page 6

Ths section's material was absorbed by another section in c-safety. It is now
free for future ideas / implementations.

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Eliminating concern for dangling pointers 7.0)                 page 7

Dangling pointers can be completely avoided in C by keeping an extra copy of
the original pointer. The idiom might be "a = b = malloc(..)" as opposed to
"a = malloc(..)". In this way we always have access to the original pointer
location and can free it without error. Presented below is a short program that 
creates a dangling pointer but then uses a copy to the original pointer it had 
saved to free it.


        #include <stdlib.h>
        #include <stdio.h>
        #include <unistd.h>

        int main(void)
        {
                char *a, *b;
                const char *string = "This is a string\n";

                a = b = malloc(32); // keep an extra copy
                while (*string)
                        *b++ = *string++; // "b" is now a dangling pointer 
                write(1, a, b - a);

                free(a); // "a" however, still points to the original location 
                return 0;
        }


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Function pointers 8.0) 			                 page 8

Function pointers make objects even more powerful by allowing them to have
functions assigned to their members. Effectively they take the struct which is 
data and the function (which has functionality) and combines them. Thus allowing
the object itself to perform actions.


	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h> 

	typedef struct{ 
	        char *rp;
		size_t len;
		int (*f)(int, int);
	} object;

	int add(int x, int y)
	{
		return x+y;
	}

	int mul(int x, int y)
	{
		return x*y;
	}

	object *object_init(object *o, int (*func)(int x, int y))
	{
		o->f = func;
		return o;
	}

	object *object_exec(object *o, int x, int y)
	{ 
		printf( "%d\n",  o->f(x, y));
		return o;
	}

	int main(void)
	{ 
		object *o = malloc(sizeof(object));

		o = object_init(o, add);

		o = object_exec(o, 2, 3);

		o = object_init(o, mul);

		o = object_exec(o, 2, 3);

			/* or */

		printf( "%d\n",  o->f(3, 3));

		free(o);

		return 0;
	} 

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Function pointers (arrays of) 8.1) 		                 page 9

The concept of function pointers can be extended to an array of function
pointers within an object. By also including an "iterator" function we can
effectively add functions into the array one at a time and then execute them
all at once with the iterator function. The initializer function is left
separate and functions are added with the obj_addaction function. Presented
below is a program that demonstrates how to create a more powerful object by 
using an array of function pointers within it.

	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h> 

	typedef struct object object;

	object *iterate(object *o);

	typedef struct object{ 
	        char *rp;
		size_t len;
		size_t actions;
		object *(*iterate)(object *o); 
		object *(*f[10])(object *o); 
	} object;

	object *obj_init(object *o)
	{
		o->iterate = iterate;
		o->rp = malloc(256);
		o->len = 0;
		o->actions = 0;
	}

	object *obj_pop(object *o)
	{
		o->len = sprintf(o->rp, "%s\n", "string here");
	}

	object *obj_write(object *o)
	{
		write(1, o->rp, o->len);
	}

	object *obj_addaction(object *o, object *(*f)(object *))
	{
		o->f[o->actions] = f;
		o->actions++;
		return o;
	}

	object *iterate(object *o)
	{
		size_t i = 0;
		for (; i < o->actions;++i) 
			o->f[i](o);
		return o;
	}

	int main(void)
	{ 
		object *o = malloc(sizeof(object));
		o = obj_init(o);
		o = obj_addaction(o, obj_pop);
		o = obj_addaction(o, obj_write);
		o = o->iterate(o);
		return 0;
	}


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Creating dynamic libraries 9.0) 		                page 10

Unlike static libraries, dynamic libraries can not be made using the `ar'
utility and instead must be constructed by supplying directions to the compiler
telling it to create them. Because our dynamic library is not going to be
installed we also have to specify the "-rpath" so that the dynamic loader knows
how to find the executable. Normally with a library that will be installed to
the end target of a system's /lib directory "-rpath" should not be specified.
Another way to do this is to not use "rpath" at all and instead execute the
test binary in place like this `LD_LIBRARY_PATH=$(pwd) ./main'. Presented below
are 5 files that can be put into a directory to create a simple dynamic library
and build system.

Makefile:

	all: 

		# Create the object code
		gcc -c frog.c dog.c swan.c -static
		# Create a dynamic library
		cc -shared -Wl,-soname,libanim.so -o libanim.so frog.o swan.o dog.o
		# And finally link it into our executable test driver "main.c"
		gcc main.c libanim.so -o main "-Wl,-rpath=$(PWD)"

	clean:

		rm frog.o dog.o swan.o libanim.so main


animals.h:

	#ifndef _ANIMALS_
	#define _ANIMALS_

	extern int dogs;
	extern int swans;
	extern int frogs;
	int inc_dogs(int);
	int inc_swans(int);
	int inc_frogs(int);

	#endif

frog.c:
	int frogs = 10;

	int inc_frogs(int d)
	{
		return d + 1;
	}
dog.c:
	int dogs = 10;

	int inc_dogs(int d)
	{
		return d + 1;
	
	}
swan.c:
	int swans = 10;

	int inc_swans(int d)
	{
		return d + 1;
	}
main.c
	#include <stdio.h>
	#include "animals.h"
	int main(void)
	{ 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs);
		dogs = inc_dogs(dogs);
		swans = inc_dogs(swans);
		frogs = inc_dogs(frogs); 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs); 
		return 0; 
	} 


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Simple objects using typedefed structs 10.0)                  page 13


It's possible to program using objects in C without all of the complicated
pointer foo-bar. Here is an example of how to program in C using only simple 
arrays of typedefed structs.

        #include <stdlib.h>
        #include <stdio.h>
        #include <unistd.h>

        typedef struct{
                char rp[1024];
                size_t len;
        } object;

        int main(void)
        {
                size_t i = 0;
                size_t lim = 10;
                object p[10];
                object *o = p;

                for (o=p; i < lim ; ++i, ++o)
                        o->len = sprintf(o->rp, "string %zu\n", i);

                for (i=0, o=p; i < lim ; ++i, ++o)
                        write(1, o->rp, o->len);

                return 0;
        }


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Unix pipelines (for a simple shell) 11.0)                     page 14
/*
Unix pipelines can be created between utilities without using a buffer of any
kind. Using the typical object it becomes simple to store the information
needed to seamlessly connect the stdin and stdout of a series of utilities.
Pipe() is not set up for the final command in the sequence. Presented below is
a small program that demonstrates the basics needed for writing a simple shell
that supports arbitrary numbers of pipes. The sequence used is equivalent to
"ls -l | wc -l | wc -l | wc -l | wc -l > outfile"
*/

        #include <stdlib.h>
        #include <stdio.h>
        #include <unistd.h>
        #include <sys/types.h>
        #include <sys/wait.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        #include <fcntl.h>

        typedef struct{
                char *cmd[3];   /* command vector */
                int in;         /* stdin */
                int out;        /* stdout */
                pid_t pids;     /* for waitpid */
                int err;        /* for waitpid */
                int piped;      /* boolean value */
                char *infp;
                char *outfp;
                int outflags;
                int boole;
        } object;

        object *piped(object *o)
        {
                int fildes[2];
                if ((pipe(fildes)) == -1)
                        return NULL;
                (o+1)->in = fildes[0];
                o->out = fildes[1];
                return o;
        }

        object *child(object *o)
        {
                dup2(o->in, STDIN_FILENO);
                dup2(o->out, STDOUT_FILENO);
                execvp(o->cmd[0], o->cmd);
                _exit(1);
                return o;
        }
        object *foreground(object *o)
        {
                waitpid(o->pids, &(o->err), 0);
                if (o->out != -1)
                        close(o->out);
                if (o->in != -1)
                        close(o->in);
                return o;
        }

        object *execute(object *o)
        {
                if ( o->infp != NULL )                  /* < */
                        if((o->in = open(o->infp, O_RDONLY)) == -1)
                                return NULL;
                if (o->outfp != NULL )                  /* >, >> */
                        if((o->out = open(o->outfp, o->outflags, 0755)) == -1)
                                return NULL;
                if (o->piped == 1)                      /* | */
                        if(!(o = piped(o)))
                                return NULL;
                if ((o->pids = fork()) == 0)
                        o = child(o);
                o = foreground(o);
                return o;
        }

        int main(void)
        {
                size_t i = 0;
                object p[10] = 
		{{{ "ls", "-l", NULL}, -1, -1, 0, 0, 1,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 1 ,NULL, NULL, 0, -1},
                {{ "wc", "-l", NULL}, -1, -1, 0, 0, 0 ,NULL, 
		"outfile", O_APPEND|O_RDWR|O_CREAT, -1}};

                object *o = p;

                for (;i<10;o++,++i)
                {
                        if (i && (o-1)->err == 0 && (o-1)->boole == 1)  /* || */
                                continue;
                        if (i && (o-1)->err != 0 && (o-1)->boole == 0)  /* && */
                                continue;
                        o = execute(o);
                }

                return 0;
        }



-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Unsigned pow 12.0 ((pow(base, floor(log10(x))+1)-1)))         page 15

The total number of values possible within a given range in base N can be
expressed as ((pow(base, floor(log10(x))+1)-1)) or (N^C) where C is the 
cardinality of the set.

N=2
C=4

scientfic
notation   decimal    binary

2^4    =   16    =    0000 (1)  0100 (5)  1000 (9)   1100 (13)
                      0001 (2)  0101 (6)  1001 (10)  1101 (14)
                      0010 (3)  0110 (7)  1010 (11)  1110 (15)
                      0011 (4)  0111 (8)  1011 (12)  1111 (16)


Using binary counting it is easy to prove this formula by iterating through all
possible values. In decimal (greater N) or with a greater cardinality (greater
C) the table of values would be much larger -- however the formula for computing
the total amount of unique values the number can hold is the same.


	#include <stdio.h>

	size_t safe_division(size_t i, size_t x)
	{
		if (x==0)
		{
			fprintf(stderr, "Divide by zero rejected\n");
			return i;
		}
		return i / x;
	}

The C standard specifies that unsigned integer types must wrap around when they
hit their maximum limit. However it is possible to keep this from happening by 
carefully precomputing each calculation to see that it can fit.  The limit of a
given size is computed with (T)-1. The function safe_multiply provides safe
bounded multiplication.

	size_t safe_multiply(size_t i, size_t x, size_t lim)
	{
		size_t tmp = safe_division(lim, i);
		if (tmp >= x)
	        {
	                fprintf(stderr, "Multiplication proposal accepted\n");
	                return i * x;
	        }else if (tmp == 0)
			return 0;
	        fprintf(stderr, "Multiplication proposal rejected\n");
	        return lim;
	}

	size_t safe_upow(size_t b, size_t c)
	{
	        size_t ret = 1;
	        while (c--)
			ret = safe_multiply(ret, b, (size_t)-1);
	        return ret;
	}

	int main(void)
	{
		size_t b = 2;
		size_t c = 128;
		printf("total range of brute elements %zu\n", safe_upow(b, c));
		return 0;
	}


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Singly linked lists (13.0))                                   page 16

Singly linked lists can be created such that the ->next members point in either
direction. The simplest possible singly linked list builds this chain backwards
sometimes leading people to believe that it needs to be reversed. Such reversal
is unneeded as the linked list can be simply created going the opposite
direction. Presented below are the functions forpop and backpop which create a
forward and backward populated linked list respectively.


	#include <stdio.h>
	#include <stdlib.h>

	typedef struct object{ 
		size_t i;
		struct object *next;
	} object;

	object *freeobj(object*);

	void *safe_free(void *a)
	{
	        free(a);
	        return NULL;
	}

	void *verbose_malloc(size_t i)
	{
		void *ret;
		if (!(ret = malloc(i))) 
			perror("malloc error: ");
		return ret;
	}

	object *forpop(object *head, size_t i)
	{
		/* modified linked list shares members forwards */
	        static object *tail = NULL;
	        object *ptr;
		if(!(ptr = verbose_malloc(sizeof(object))))
			return head = freeobj(head);

	        ptr->next = NULL;
	        ptr->i = i;
	        if (!(head))
	                tail = head = ptr;
	        else if (tail){
	                tail->next = ptr;
	                tail = ptr;
	        }
	        return head;
	}

	object *backpop(object *head, size_t i)
	{
		/* simple linked list shares members backwards */
		object* o;
		if (!(o = verbose_malloc(sizeof(object))))
			return head = freeobj(head);
		o->i = i;
		o->next = head;
		return o;
	}

	void iterate(object* head)
	{
		object *o;
		for(o = head;o;o = o->next) 
			printf("(%zu)-->", o->i); 
		printf("END\n\n");
	}

	object *placefreeobj(object *hold)
	{
		if (hold)
	        {
	                printf("free(%zu)-->", hold->i);
	                hold = safe_free(hold);
	        }
		return hold;
	}

	object *freeobj(object *head)
	{
	        object *o;
		object *hold = NULL;
	        for(o = head;o;o = o->next)
		{
			hold = placefreeobj(hold);
			hold = o; 
		}
		hold = placefreeobj(hold);
	
		if (o == head)
			printf("Nothing to be freed  ");
	        printf("END\n\n");
		return hold;
	}

	int main(void)
	{ 
		size_t i;
		object* head = NULL; 
		for(i = 0; i<=20; i++) 
			if (!(head = forpop(head, i)))
				return 1;
	
		iterate(head);
		head = freeobj(head);
	
		for(i = 0; i<=20; i++) 
			if (!(head = backpop(head, i)))
				return 1;
	
		iterate(head);
		head = freeobj(head);

		return 0;
	} 

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Safe reallocation)                                            page 17

There are very few tricks that universally apply to all C memory management. By
using the idiom of passing the "value of a pointer to a pointer to a type" to a
wrapper for free, realloc and malloc however, one can force a number of useful
scenarios. One such scenario is to take advantage of the C standard's specified
behavior for realloc; "If memory for the new object cannot be allocated, the 
old object is not deallocated and its value is unchanged" (from the C11 draft).
We can therefore reduce this operation to a single line of code using a wrapper
function. Similarly, all freed memory can be explicitly made to point to NULL
. Malloc in this case performs no special function but is wrapped in the same
way as free and realloc so as to present a consistent API.

	#include <stdio.h>
	#include <stdlib.h>

	int safe_free(void **a)
	{ 
		free(*a);
		*a = NULL;
		return 1;
	}

	int safe_realloc(void **a, size_t i)
	{
		void *tmp;
		if (!(tmp = realloc(*a, i)))
		{
			perror("Realloc error: ");
			return -1;
		}
		*a = tmp;
		return 1;
	}

	int safe_malloc(void **a, size_t i)
	{ 
	        if (!(*a = malloc(i)))
	        {
	                perror("Malloc error: ");
	                return -1;
	        }
		return 1;
	}

	int main(void)
	{
		char *a;
		size_t i = 0;
		if (!(safe_malloc((void**)&a, 1)))
			return 1; 
		if (!(safe_realloc((void**)&a, 10)))
			return 1; 
		if (a)
			printf("a  exists\n"); 
		for (i=0;i < 10;++i)
			a[i];
		printf("First reallocation successful\n");
		if (!(safe_realloc((void**)&a, (size_t)-1))) // will fail
			;//return 1
		if (a) printf("a  exists\n");
		for (i=0;i < 10;++i)
			a[i];
		printf("Second reallocation left the pointer unchanged\n");
		if(!(safe_free((void**)&a)))
			;// NULL pointers passed to free indicate design flaw 
		return 0;
	}


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Doubly linked list)                                           page 18

A doubly linked list is a data structure of nodes linked together in both
directions. These node creation and traversal directions are accessed with the
structure members "prev" and "next". NULL is used for the linked list terminal
end points.

[x] = prev <-[o]
             [o]->next = [o]
             [o] = prev<-[o]
                         [o]->next = [o]
                         [o] = prev<-[o]
                                     [o]->next = [o]
                                     [o] = prev<-[o] 
                                                 [o]->next = [o]
                                                 [o] = prev<-[o]
                                                             [o]->next = [x]

Here is a program to implement a basic doubly linked list with node insertion
and deletion;

	#include <stdio.h>
	#include <stdlib.h>

	typedef struct object {
		size_t i;
		struct object *prev;
		struct object *next;
	} object;

	object *initlist(size_t);

	size_t objectsize(void)
	{
		return sizeof(object);
	}

	void *safe_free(void *a)
	{
	        free(a);
	        return NULL;
	}

	void *verbose_malloc(size_t i)
	{
	        void *ret;
	        if (!(ret = malloc(i)))
	                perror("malloc error: ");
	        return ret;
	}

	object *insertnode(object *o, size_t i)
	{ 
		object *ptr = initlist(i);
		ptr->prev = o;
		ptr->next = o->next;
		o->next->prev = ptr;
		o->next = ptr; 
		return ptr;
	}
	
	object *deletenode(object *o)
	{ 
		object *tmp = o->prev;
		o->prev->next = o->next;
		o->next->prev = o->prev; 
		o = safe_free(o); 
		return tmp;
	}
	
	object *initlist(size_t i)
	{ 
		object *o = verbose_malloc(objectsize()); 
		if (!(o))
			return NULL; 
	        o->i = i;
	        o->prev = o->next = NULL; /* terminal NODES */
		return o;
	}
	
	object *delhead(object *o)
	{ 
	        object *tmp = o->next;
	        o->next->prev = NULL; 
	        o = safe_free(o);
	        return tmp;
	}
	
	object *deltail(object *o)
	{ 
	        object *tmp = o->prev;
	        o->prev->next = NULL; 
	        o = safe_free(o);
	        return tmp;
	}
	
	object *addhead(object *o, size_t i)
	{ 
		object *ptr = initlist(i); 
		ptr->next = o;
		o->prev = ptr;
		return ptr;
	} 
	
	object *addtail(object *o, size_t i)
	{
		object *ptr = initlist(i); 
		ptr->prev = o;
		o->next = ptr;
		return ptr;
	} 
	
	void listbackward(object *ptr)
	{ 
		for(;ptr;ptr = ptr->prev)
			printf("%zu ", ptr->i); 
		printf("\n\n");
	}
	
	void listforward(object *ptr)
	{
		for(;ptr;ptr = ptr->next)
			printf("%zu ", ptr->i);
		printf("\n\n");
	}
	
	object *placefreeobj(object *hold)
	{
	        if (hold) 
	        	printf("free(%zu)--> ", hold->i);
	        return safe_free(hold);
	}
	
	object *freeobj(object *head)
	{
	        object *o;
	        object *hold = NULL;
	        for(o = head;o;o = o->next)
	        {
	                hold = placefreeobj(hold);
	                hold = o;
	        }
	        hold = placefreeobj(hold);
	
	        if (o == head)
	                printf("Nothing to be freed  ");
	        printf("END\n\n");
	        return hold;
	}
	
	int main(void)
	{
		size_t i = 0; 
		object *head = NULL;
		object *tail = NULL;
		object *o;
	
		/* create */
		tail = head = initlist(i);
	
		/* add to tail */
		for (i =1; i <= 20; i++) 
			tail = addtail(tail, i); 
		listforward(head);
		listbackward(tail);
	
		/* add to head */
		for (i=30; i <= 40; i++)
			head = addhead(head, i); 
		listforward(head);
		listbackward(tail); 
		
		/* node deletion */
	        for(i=0,o = head;o;o = o->next,++i)
	                if (i >3 && i < 13)
				o = deletenode(o); 
		listforward(head);
		listbackward(tail); 
	
		/* node insertion */
	        for(i=0,o = head;o;o = o->next,++i)
	                if (i >3 && i < 13)
				o = insertnode(o, i);
		
		listforward(head);
		listbackward(tail);
	
		/* delete from head */
		head = delhead(head);
		head = delhead(head);
	
		/* delete from tail */
		tail = deltail(tail);
		tail = deltail(tail);
		
		listforward(head);
		listbackward(tail);
	
		/* free the list and NULL the root and tail nodes */
		tail = head = freeobj(head); 
		return 0; 
	}


-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Tries, R-way trie)                                            page 19

Retrieval trees (tries) offer 0(N) time complexity on lookup operations. Tries 
have the unique property of aborting upon an "early miss", which greatly 
increases their effectiveness.  

        "Proposition G. The number of array accesses when 
         searching in a trie or inserting a key into a trie
         is at most 1 plus the length of the key." 
                 (Sedgewick, "Algorithms" 4th ed. pg730)


Typically in depictions of tries NULL nodes are not shown, as is the case in
the depiction below:


             [root]                   andy
          /          \                android
       [a]            [b]             androids
        |              |              andrew
       [n]            [a]             androgen
        |  \           |              ant
       [d] [t]        [r]
     /  |              |  \           barnacle
   [y] [r]            [r] [n]         barney
        |  \           |   |  \       barry
       [e] [o]        [y] [a] [e]
        |   | \            |   |
       [w] [i] [g]        [c] [y]
            |   |          |
           [d] [e]        [l]
         /      |          |
       [s]     [n]        [e]

An r-way trie carries no data in the structure members of its nodes. Instead,
the data is implied by mapping an element of the key to a node thus rendering 
the node no longer NULL. 

The program below presents an R-way trie. Insertion, deletion, searching,
printing and histogram functions are supplied. The function getword() was
adapted from K&R2 so that the dictionary algorithm can compare a file of words
against itself or multiple lines supplied interactively by entering them and
then ctrl-d. Getword is simply a driver to assist main.



	#include <stdio.h>
	#include <stdlib.h> 
	#include <string.h>
	#include <ctype.h>
	
	size_t alphasize = 128;
	
	typedef struct object {
		int leaf; 
		struct object **children; 
	}object;
	
	int trie_isfreenode(object *o)
	{
		size_t i;
		for(i = 0; i < alphasize; i++)
			if(o->children[i])
				return 0;
		return 1;
	}
	
	int _trie_nodel(object *o, char *key, size_t level)
	{ 
		size_t index;
		if(!(o))
	   		return 0;
		if(key[level] == 0)
		{
			if(o->leaf)
			{
				o->leaf = 0;
				if(trie_isfreenode(o))
					return 1;
			} 
			return 0; 
		}
		index = key[level];
		if(_trie_nodel(o->children[index], key, level+1))
		{ 
			free(o->children[index]->children);
			free(o->children[index]);
			o->children[index] = NULL;
			return (!o->leaf && trie_isfreenode(o));
		}
		return 0;
	}
	
	int trie_nodel(object *o, char *key)
	{
		size_t level = 0;
		_trie_nodel(o, key, level);
	}
	
	object *trie_init(void)
	{
		size_t i = 0; 
		object *o = malloc(sizeof(object)); 
		if (!(o))
			return NULL;
		o->leaf = 0;
		if (!(o->children = malloc(sizeof(object) * alphasize)))
			return NULL;
		for (i = 0; i < alphasize; i++) 
			o->children[i] = NULL; 
		return o;
	} 
	
	void trie_insert(object *o, const char *pat)
	{
		size_t i; 
		size_t ind; 
		for (i = 0; pat[i]; i++)
		{
			ind = pat[i]; 
			if (!o->children[ind])
				o->children[ind] = trie_init(); 
			o = o->children[ind];
		}
		o->leaf = 1;
	} 
	
	int trie_search(object *o, const char *pat)
	{
		size_t i;
		size_t ind; 
		for (i = 0; pat[i]; i++)
		{
			ind = pat[i];
			if (!o->children[ind])
				return 0; 
			o = o->children[ind];
		} 
		if ( o != NULL && o->leaf)
			return 1;
		return 0; 
	} 
	
	void trie_free(object* root)
	{ 
		size_t i;
		for (i = 0; i < alphasize; i++)
		{
			if (root->children[i])
				trie_free(root->children[i]);
		}
		free(root->children);
		free(root);
	}
	
	void _trie_histogram(object* root, size_t level)
	{ 
		size_t i; 
		static char str[100]; 
		if (root->leaf)
		{
			str[level] = '\0';
			printf("\t\t\t    -->(%s)\n|", str); 
		}
		for (i = 0; i < alphasize; i++)
		{ 
			if (root->children[i])
			{
				printf("-%c", (int)i);
				str[level] = i; 
				_trie_histogram(root->children[i], level + 1);
			}
		}
	}
	
	void trie_histogram(object* root)
	{
		printf("root\n|\n|\n|");
		_trie_histogram(root, 0);
	}
	
	void _trie_display(object* root, size_t level)
	{ 
		size_t i;
		static char str[1024];
		if (root->leaf)
		{
			str[level] = '\0';
			printf("%s\n", str); 
		} 
		for (i = 0; i < alphasize; i++)
		{
			if (root->children[i])
			{
				str[level] = i;
				_trie_display(root->children[i], level + 1);
			}
		}
	}
	
	void trie_display(object* root)
	{
		size_t level = 0;
		_trie_display(root, level);
	}
	
	int getword(char *word, size_t lim, FILE *fp)
	{
	        int c;
	        char *w = word;
	        while (isspace(c = fgetc(fp)));
		        if (c != EOF)
	                *w++ = c;
	        if (!isalnum(c) && !ispunct(c))
	                { *w = '\0'; return c; }
	        for ( ; --lim > 0; w++)
	        {
	                *w = fgetc(fp);
	                if (!isalnum(*w) && !ispunct(*w))
	                        { ungetc(*w, fp); break; }
	        }
	        *w = '\0';
	        return word[0];
	}
	
	int main(int argc, char *argv[])
	{
		size_t i = 0;
		char word[100];
	        FILE *fp = stdin;
	        if ( argc == 2 )
	                if (!(fp = fopen(argv[1], "r")))
	                        return 1;
	
		object *root = trie_init();
		object *p = root;
		while (getword(word, 100, fp) != EOF)
			trie_insert(root, word);
	
	        if (fp!=stdin)rewind(fp);
	
	        while (getword(word, 100, fp) != EOF)
	        {
	                if (trie_search(root, word))
	                        printf("found %s\n", word);
	                else
	                        printf("not found %s\n", word);
	        }
		trie_display(root); 
		trie_histogram(root); 
		if (fp!=stdin)rewind(fp);
		while (getword(word, 100, fp) != EOF) 
			trie_nodel(root, word); 
		if (fp!=stdin)rewind(fp); 
		trie_display(root);
		printf("\n");
		trie_histogram(root); 
		trie_free(root);
		if (fp!=stdin)fclose(fp);
		return 0;
	}




