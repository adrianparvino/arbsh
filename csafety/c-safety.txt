c-safety (programming with abstract objects)			page 1

The C standard identifies objects in a very broad sense and applies the
term to "any object in memory". However this definition of object does
not address the power that C has to create and use objects in a modern
sense of it being the primary predecessor to "object oriented
programing".

Presented below is a method of "programming with objects" in C.




	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h>

	typedef struct{ 
	        char *rp; 
		size_t len;
	} object; 

	int main(void)
	{ 
		size_t i = 0;
		size_t lim = 10;

		/* create an array of objects */
		object *o = malloc(sizeof(object) * lim); 

		/* 
			allocate memory for and populate the 
			members of the array of objects 
		*/

		for ( ; i < lim ; ++i)
		{
			(o+i)->rp = malloc(sizeof(char) * 100);
			(o+i)->len = sprintf((o+i)->rp, "string %zu\n", i); 
		} 
	
		/* test the array of objects (fast write!) */
		for (i=0 ; i < lim ; ++i)
			write(1, (o+i)->rp, (o+i)->len);
	
		/* free the objects' member memory allocations */
		for (i=0 ; i < lim ; ++i)
       	         free((o+i)->rp);
	
		/* free the object */
		free(o);
	
		return 0; 
	}















-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Pass by address of a pointer to a pointer)   	                page 2


C does not support "pass by reference" nonetheless by passing the value
of an address to a function which accepts a pointer to a pointer to a 
type we can modify a value in C similiar to C++'s "pass by reference". 
The canonical example of this is getline() from the C standard library.

Presented below is the function pass_bappt() (Pass by address of a
pointer to a pointer to a type).



	#include <stdlib.h>
	#include <stdio.h>
	typedef struct{ 
	        char *rp; 
		size_t len; /* len is not used in this example */
	} object;

	void does_not_work(char *a) 
	{
		/* Doesn't work! (obviously) */
		a = "Does not work!";
	}

	void pass_bappt(char **a) 
	{ 
		/*
			"Pass by value of an address of a pointer to a pointer to a 
			 type (pass_baapt)"
		*/
		*a = "hello world";
	}

	int main(void)
	{ 
		object *o;
		o = malloc(sizeof(object)); 
	
		o->rp = "This pointer to a string literal should be overwritten\n";
	
     		printf("%s\n", o->rp);

	        pass_bappt(&(o->rp)); /* note the '&' */
   
    		printf("%s\n", o->rp);
     
      		does_not_work(o->rp);  /* Doesn't work! (obviously) */
	
		printf("%s\n", o->rp);
	

		free(o);
		return 0; 
	}












-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
