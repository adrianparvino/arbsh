c-safety (programming with abstract objects 1.0)		page 1

The C standard identifies objects in a very broad sense and applies the
term to "any object in memory". However this definition of object does
not address the power that C has to create and use objects in a modern
sense of it being the primary predecessor to "object oriented
programing".

Presented below is a method of "programming with objects" in C.




	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h>

	typedef struct{ 
	        char *rp; 
		size_t len;
	} object; 

	int main(void)
	{ 
		size_t i = 0;
		size_t lim = 10;

		/* create an array of objects */
		object *o = malloc(sizeof(object) * lim); 

		/* 
			allocate memory for and populate the 
			members of the array of objects 
		*/

		for ( ; i < lim ; ++i)
		{
			(o+i)->rp = malloc(sizeof(char) * 100);
			(o+i)->len = sprintf((o+i)->rp, "string %zu\n", i); 
		} 
	
		/* test the array of objects (fast write!) */
		for (i=0 ; i < lim ; ++i)
			write(1, (o+i)->rp, (o+i)->len);
	
		/* free the objects' member memory allocations */
		for (i=0 ; i < lim ; ++i)
       	         free((o+i)->rp);
	
		/* free the object */
		free(o);
	
		return 0; 
	}















-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Pass by address of a pointer to a pointer 2.0)	         page 2


C does not support "pass by reference" nonetheless by passing the value
of an address to a function which accepts a pointer to a pointer to a 
type we can modify a value in C similar to C++'s "pass by reference". 
The canonical example of this is getline() from the C standard library.

Presented below is the function pass_bappt() (Pass by address of a
pointer to a pointer to a type).



	#include <stdlib.h>
	#include <stdio.h>
	typedef struct{ 
	        char *rp; 
		size_t len; /* len is not used in this example */
	} object;

	void does_not_work(char *a) 
	{
		/* Doesn't work! (obviously) */
		a = "Does not work!";
	}

	void pass_bappt(char **a) 
	{ 
		/*
			"Pass by value of an address of a pointer to a pointer to a 
			 type (pass_baapt)"
		*/
		*a = "hello world";
	}

	int main(void)
	{ 
		object *o;
		o = malloc(sizeof(object)); 
	
		o->rp = "This pointer to a string literal should be overwritten\n";
	
     		printf("%s\n", o->rp);

	        pass_bappt(&(o->rp)); /* note the '&' */
   
    		printf("%s\n", o->rp);
     
      		does_not_work(o->rp);  /* Doesn't work! (obviously) */
	
		printf("%s\n", o->rp);
	

		free(o);
		return 0; 
	}


Note that this creates an "anti-pattern" within the C programming langauge.
Ideally values are saved using a different mechanism such as passing an object 
with mutable members to a function and then returning that object to the calle
(the calling function).






-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Prevent double frees 3.0)	   	              		page 3


The C11 draft states "If ptr is a null pointer, no action occurs."
therefore preventing "double frees" is reduced to the simple
operation of explicitly setting deallocated variables to NULL.  


	#include <stdlib.h>
	#include <stdio.h> 

	typedef struct{ 
	        char *rp; 
		size_t len;
	}object;

	void *safe_free(void *a) 
	{ 
		free(a); 
		return NULL; 
	}

	int main(void)
	{
		char *l; 
		object *o;
		o = malloc(sizeof(object));
		o->rp = malloc(1000); 
		o->rp = safe_free(o->rp);
		o->rp = safe_free(o->rp); // does nothing
		o = safe_free(o);
		o = safe_free(o); // does nothing

		return 0; 
	}

































-------------------------------------------------------------------------------
------------------------------------------------------------------------------- 
c-safety (Opaque objects and pointers 4.0)                               page 4

This program attempts to use the opaque-objects we create.
It has the ability to access and use the type "object" but not its
structure members. The opaque object can only be manipulated via
its API. Which in this case are the simple functions object_init ..
and so on.

main.c:
	#include "shared.h"
	int main(void)
	{
		object *o;
		o = object_init(o);
		object_populate(o, "This is a string\n");
		object_write(o);
		object_free(o);

		//o->rp = "hello";  //<-- This will fail to compile if it is a truly opaque type,
				    // producing the error: "dereferencing pointer to incomplete
			            // type â€˜object {aka struct object}" thus proving that the 
				    // implementation details are indeed hidden from the user of 
				    // the API. Uncomment it to verify
		return 0;
	}


Makefile:
	all:

		gcc -c opaque.c -o opaque.o
		gcc main-driver.c opaque.o -o main-driver

	clean:

		rm *.o
		rm main-driver



This is the actual opaque API library implementation. We declare an
instantiation of the primary API structure from "shared.h" our shared
header. But in this version we actually define its members. Inside of
this file we can access all of the members of our opaque type but the
end user of the API, or indeed anyone outside of this file can not.
However, they can use the library as a library of opaque objects. The
canonical example of the opaque object in C is the FILE * structure
from stdio.  


opaque.c
	#include <stdlib.h>
	#include <stdio.h>
	#include <unistd.h>
	#include <string.h>
	#include "shared.h"


	struct object {
		char *rp;
		size_t len;
	}; 






-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Opaque objects and pointers 4.0)                               page 5

opaque.c (continued):
	size_t object_size(void)
	{
		return sizeof(object);
	}

	object *object_init(object *o)
	{
		o = malloc (object_size());
		o->len = 0;
		return o;
	}

	object *object_populate(object *o, char *s)
	{
		o->rp = s;
		o->len = strlen(s);
	}

	void object_free(object *o)
	{ 
		free(o);
	}

	void object_write(object *o)
	{
		write(1, o->rp, o->len);
	}


shared.h:
	#include <stddef.h>

	typedef struct object object; 
	size_t object_size(void); 
	object *object_init(object *);
	object *object_populate(object *, char *);
	void object_write(object *);
	void object_free(object *);



























-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Creating static libraries with ar 5.0)                         page 6

ar has been around for a long time. and it makes very simple archives. These
very simple archives happen to be readable by the compiler and we can
concatenate object code more or less endlessly into one of these .a and then
use it as a "library". Another type of library is called a dynamic library and
they end with .so.

Static libraries get the entire archive of object code linked into the executable.
Conversely, dynamic libraries sit in /lib and are loaded at runtime. Static 
binaries will work in a chroot with no other libs at all. However, they may still
have other dependencies such as /proc or the terminfo database.


Makefile:
	all: 

		# create the object code
		gcc -c frog.c dog.c swan.c -static
		# Here we use `ar' to create the static library "libanimals.a"
		ar -cvq libanimals.a frog.o dog.o swan.o 
		# And finally link it into our executable test driver "main.c"
		gcc main.c libanimals.a -o main -static

	clean:

		rm frog.o dog.o swan.o libanimals.a main

dog.c:
	int dogs = 10;

	int inc_dogs(int d)
	{
		return d + 1;
	}

frog.c:
	int frogs = 10;

	int inc_frogs(int d)
	{
		return d + 1;
	}

swan.c:
	int swans = 10;

	int inc_swans(int d)
	{
		return d + 1;
	}

main.c:
	#include <stdio.h>
	#include "animals.h"
	int main(void)
	{ 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs);
		dogs = inc_dogs(dogs);
		swans = inc_dogs(swans);
		frogs = inc_dogs(frogs); 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs); 
		return 0; 
	}

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Safe multiplication 6.0)		                         page 7


The C standard specifies that unsigned integer types must wrap around
when they hit their maximum limit. However it is possible to keep this
from happening by carefully precomputing each calculation to see that
it can fit. The limit of a given size is computed with (T)-1. Presented 
below is an idea for safe bounded multiplication.
	

	#include <stdio.h>
	size_t safe_multiply(size_t i, size_t x, size_t lim)
	{
		if (i == 0) /* Handle zero */
			return 0;
		if (lim / i >= x ) 
		{
			fprintf(stderr, "Muliplication proposal accepted\n");
			return i * x;
		}
		fprintf(stderr, "Muliplication proposal rejected\n");
		return lim;
	}

	int main(void)
	{
		size_t a = (size_t) -1; 
		a = safe_multiply(a, 123123, (size_t) -1); 
		printf("%zu\n", a);
	
		a = (size_t) -1 / 10;
		a = safe_multiply(a, 123123, (size_t) -1);
		printf("%zu\n", a);

		unsigned int b = (unsigned int) -1;
		b = safe_multiply(b, 123123, (unsigned int) -1);
		printf("%u\n", b); 
	
		b = 500;
		b = safe_multiply(b, 1000000, (unsigned int) -1);
		printf("%u\n", b);
		
		b = (unsigned int) -1;
		b = safe_multiply(b, b - 123, (unsigned int) -1);
		printf("%u\n", b);

		return 0;
	}



















-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Eliminating concern for dangling pointers 7.0)                 page 8

Dangling pointers can be completely avoided in C by keeping an extra copy of
the original pointer. The idiom might be "a = b = malloc(..)" as opposed to
"a = malloc(..)". In this way we always have access to the original pointer
location and can free it without error. Presented below is a short program that 
creates a dangling pointer but then uses a copy to the original pointer it had 
saved to free it.


	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h>

	int main(void)
	{ 
		char *a;
		char *b;
		const char *string = "This is a string\n";

		a = b = malloc(32); // Always keep at least 2 copies of
				    // of the original pointer location.
		while (*string)
		{
			*b = *string;
			++string;
			++b; // "b" is now a dangling pointer
			     // and can not be freed
		}

	
		write(1, a, b - a); // when "b" is incremented away from "a" and
				    // becomes a dangling pointer then we can
				    // calculate the length of the object as b-a.

		free(a); // "a" however points at the original
			 // location that "b" pointed to and
			 // can be used to free the memory
		return 0; 
	}




























-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Function pointers 8.0) 			                 page 9

Function pointers make objects even more powerful by allowing them to have
functions assigned to their members. Effectively they take the struct which is 
data and the function (which has functionality) and combines them. Thus allowing
the object itself to perform actions.


	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h> 

	typedef struct{ 
	        char *rp;
		size_t len;
		int (*f)(int, int);
	} object;

	int add(int x, int y)
	{
		return x+y;
	}

	int mul(int x, int y)
	{
		return x*y;
	}

	object *object_init(object *o, int (*func)(int x, int y))
	{
		o->f = func;
		return o;
	}

	object *object_exec(object *o, int x, int y)
	{ 
		printf( "%d\n",  o->f(x, y));
		return o;
	}

	int main(void)
	{ 
		object *o = malloc(sizeof(object));

		o = object_init(o, add);

		o = object_exec(o, 2, 3);

		o = object_init(o, mul);

		o = object_exec(o, 2, 3);

			/* or */

		printf( "%d\n",  o->f(3, 3));

		free(o);

		return 0;
	}








-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Function pointers (arrays of) 8.1) 		                page 10

The concept of function pointers can be extended to an array of function
pointers within an object. By also including an "iterator" function we can
effectively add functions into the array one at a time and then execute them
all at once with the iterator function. The initializer function is left
seperate and functions are added with the obj_addaction function. Presented
below is a program that demonstrates how to create a powerful object using an 
array of function pointers

	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h> 

	typedef struct object object;

	object *iterate(object *o);

	typedef struct object{ 
	        char *rp;
		size_t len;
		size_t actions;
		object *(*iterate)(object *o); 
		object *(*f[10])(object *o); 
	} object;

	object *obj_init(object *o)
	{
		o->iterate = iterate;
		o->rp = malloc(256);
		o->len = 0;
		o->actions = 0;
	}

	object *obj_pop(object *o)
	{
		o->len = sprintf(o->rp, "%s\n", "string here");
	}

	object *obj_write(object *o)
	{
		write(1, o->rp, o->len);
	}

	object *obj_addaction(object *o, object *(*f)(object *))
	{
		o->f[o->actions] = f;
		o->actions++;
		return o;
	}

	object *iterate(object *o)
	{
		size_t i = 0;
		for (; i < o->actions;++i) 
			o->f[i](o);
		return o;
	}

	int main(void)
	{ 
		object *o = malloc(sizeof(object));
		o = obj_init(o);
		o = obj_addaction(o, obj_pop);
		o = obj_addaction(o, obj_write);
		o = o->iterate(o);
		return 0;
	}
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

