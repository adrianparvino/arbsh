c-safety (programming with abstract objects 1.0)		page 1

The C standard identifies objects in a very broad sense and applies the
term to "any object in memory". However this definition of object does
not address the power that C has to create and use objects in a modern
sense of it being the primary predecessor to "object oriented
programing".

Presented below is a method of "programming with objects" in C.




	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h>

	typedef struct{ 
	        char *rp; 
		size_t len;
	} object; 

	int main(void)
	{ 
		size_t i = 0;
		size_t lim = 10;

		/* create an array of objects */
		object *o = malloc(sizeof(object) * lim); 

		/* 
			allocate memory for and populate the 
			members of the array of objects 
		*/

		for ( ; i < lim ; ++i)
		{
			(o+i)->rp = malloc(sizeof(char) * 100);
			(o+i)->len = sprintf((o+i)->rp, "string %zu\n", i); 
		} 
	
		/* test the array of objects (fast write!) */
		for (i=0 ; i < lim ; ++i)
			write(1, (o+i)->rp, (o+i)->len);
	
		/* free the objects' member memory allocations */
		for (i=0 ; i < lim ; ++i)
       	         free((o+i)->rp);
	
		/* free the object */
		free(o);
	
		return 0; 
	}















-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Pass by address of a pointer to a pointer 2.0)	         page 2


C does not support "pass by reference" nonetheless by passing the value
of an address to a function which accepts a pointer to a pointer to a 
type we can modify a value in C similar to C++'s "pass by reference". 
The canonical example of this is getline() from the C standard library.

Presented below is the function pass_bappt() (Pass by address of a
pointer to a pointer to a type).



	#include <stdlib.h>
	#include <stdio.h>
	typedef struct{ 
	        char *rp; 
		size_t len; /* len is not used in this example */
	} object;

	void does_not_work(char *a) 
	{
		/* Doesn't work! (obviously) */
		a = "Does not work!";
	}

	void pass_bappt(char **a) 
	{ 
		/*
			"Pass by value of an address of a pointer to a pointer to a 
			 type (pass_baapt)"
		*/
		*a = "hello world";
	}

	int main(void)
	{ 
		object *o;
		o = malloc(sizeof(object)); 
	
		o->rp = "This pointer to a string literal should be overwritten\n";
	
     		printf("%s\n", o->rp);

	        pass_bappt(&(o->rp)); /* note the '&' */
   
    		printf("%s\n", o->rp);
     
      		does_not_work(o->rp);  /* Doesn't work! (obviously) */
	
		printf("%s\n", o->rp);
	

		free(o);
		return 0; 
	}


Note that this creates an "anti-pattern" within the C programming language.
Ideally values are saved using a different mechanism such as passing an object 
with mutable members to a function and then returning that object to the caller
(the calling function).






-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Prevent double frees 3.0)	   	              		page 3


The C11 draft states "If ptr is a null pointer, no action occurs."
therefore preventing "double frees" is reduced to the simple
operation of explicitly setting deallocated variables to NULL.  


	#include <stdlib.h>
	#include <stdio.h> 

	typedef struct{ 
	        char *rp; 
		size_t len;
	}object;

	void *safe_free(void *a) 
	{ 
		free(a); 
		return NULL; 
	}

	int main(void)
	{
		char *l; 
		object *o;
		o = malloc(sizeof(object));
		o->rp = malloc(1000); 
		o->rp = safe_free(o->rp);
		o->rp = safe_free(o->rp); // does nothing
		o = safe_free(o);
		o = safe_free(o); // does nothing

		return 0; 
	}

































-------------------------------------------------------------------------------
------------------------------------------------------------------------------- 
c-safety (Opaque objects and pointers 4.0)                               page 4

This program (main.c) attempts to use the opaque-objects we create.
It has the ability to access and use the type "object" but not its
structure members. The opaque object can only be manipulated via
its API. Which in this case are the simple functions object_init ..
and so on.

main.c:
	#include "shared.h"
	int main(void)
	{
		object *o;
		o = object_init(o);
		object_populate(o, "This is a string\n");
		object_write(o);
		object_free(o);

		//o->rp = "hello";  /* <-- This will fail to compile if it is a
				     truly opaque type, producing the error: 
				     "dereferencing pointer to incomplete type 
				     â€˜object {aka struct object}" thus proving 
			             that the implementation details are indeed 
				     hidden from the user of the API. Uncomment 
				     it to verify */
		return 0;
	}


Makefile:
	all:

		gcc -c opaque.c -o opaque.o
		gcc main-driver.c opaque.o -o main-driver

	clean:

		rm *.o
		rm main-driver



Presented here (in opaque.c) is the actual opaque API library implementation. 
We declare an instantiation of the primary API structure from "shared.h" our 
shared header. But in this version we actually define its members. Inside of
this file we can access all of the members of our opaque type but the end user 
of the API, or indeed anyone outside of this file can not.  However, they can 
use the library as a library of opaque objects. The canonical example of the 
opaque object in C is the FILE * structure from stdio.  


opaque.c (part 1):
	#include <stdlib.h>
	#include <stdio.h>
	#include <unistd.h>
	#include <string.h>
	#include "shared.h"


	struct object {
		char *rp;
		size_t len;
	}; 





-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Opaque objects and pointers 4.0)                               page 5

opaque.c (part 2):
	size_t object_size(void)
	{
		return sizeof(object);
	}

	object *object_init(object *o)
	{
		o = malloc (object_size());
		o->len = 0;
		return o;
	}

	object *object_populate(object *o, char *s)
	{
		o->rp = s;
		o->len = strlen(s);
	}

	void object_free(object *o)
	{ 
		free(o);
	}

	void object_write(object *o)
	{
		write(1, o->rp, o->len);
	}


shared.h:
	#include <stddef.h>

	typedef struct object object; 
	size_t object_size(void); 
	object *object_init(object *);
	object *object_populate(object *, char *);
	void object_write(object *);
	void object_free(object *);



























-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Creating static libraries with ar 5.0)                         page 6

ar has been around for a long time. and it makes very simple archives. These
very simple archives happen to be readable by the compiler and we can
concatenate object code more or less endlessly into one of these .a and then
use it as a "library". Another type of library is called a dynamic library and
they end with .so.

Static libraries get the entire archive of object code linked into the executable.
Conversely, dynamic libraries sit in /lib and are loaded at runtime. Static 
binaries will work in a chroot with no other libs at all. However, they may still
have other dependencies such as /proc or the terminfo database.


Makefile:
	all: 

		# create the object code
		gcc -c frog.c dog.c swan.c -static
		# Here we use `ar' to create the static library "libanimals.a"
		ar -cvq libanimals.a frog.o dog.o swan.o 
		# And finally link it into our executable test driver "main.c"
		gcc main.c libanimals.a -o main -static

	clean:

		rm frog.o dog.o swan.o libanimals.a main

dog.c:
	int dogs = 10;

	int inc_dogs(int d)
	{
		return d + 1;
	}

frog.c:
	int frogs = 10;

	int inc_frogs(int d)
	{
		return d + 1;
	}

swan.c:
	int swans = 10;

	int inc_swans(int d)
	{
		return d + 1;
	}

main.c:
	#include <stdio.h>
	#include "animals.h"
	int main(void)
	{ 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs);
		dogs = inc_dogs(dogs);
		swans = inc_dogs(swans);
		frogs = inc_dogs(frogs); 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs); 
		return 0; 
	}

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Safe multiplication 6.0)		                         page 7


The C standard specifies that unsigned integer types must wrap around
when they hit their maximum limit. However it is possible to keep this
from happening by carefully precomputing each calculation to see that
it can fit. The limit of a given size is computed with (T)-1. Presented 
below is an idea for safe bounded multiplication.
	

	#include <stdio.h>
	size_t safe_multiply(size_t i, size_t x, size_t lim)
	{
		if (i == 0) /* Handle zero */
			return 0;
		if (lim / i >= x ) 
		{
			fprintf(stderr, "Muliplication proposal accepted\n");
			return i * x;
		}
		fprintf(stderr, "Muliplication proposal rejected\n");
		return lim;
	}

	int main(void)
	{
		size_t a = (size_t) -1; 
		a = safe_multiply(a, 123123, (size_t) -1); 
		printf("%zu\n", a);
	
		a = (size_t) -1 / 10;
		a = safe_multiply(a, 123123, (size_t) -1);
		printf("%zu\n", a);

		unsigned int b = (unsigned int) -1;
		b = safe_multiply(b, 123123, (unsigned int) -1);
		printf("%u\n", b); 
	
		b = 500;
		b = safe_multiply(b, 1000000, (unsigned int) -1);
		printf("%u\n", b);
		
		b = (unsigned int) -1;
		b = safe_multiply(b, b - 123, (unsigned int) -1);
		printf("%u\n", b);

		return 0;
	}



















-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Eliminating concern for dangling pointers 7.0)                 page 8

Dangling pointers can be completely avoided in C by keeping an extra copy of
the original pointer. The idiom might be "a = b = malloc(..)" as opposed to
"a = malloc(..)". In this way we always have access to the original pointer
location and can free it without error. Presented below is a short program that 
creates a dangling pointer but then uses a copy to the original pointer it had 
saved to free it.


	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h>

	int main(void)
	{ 
		char *a;
		char *b;
		const char *string = "This is a string\n";

		a = b = malloc(32); // Always keep at least 2 copies of
				    // of the original pointer location.
		while (*string)
		{
			*b = *string;
			++string;
			++b; // "b" is now a dangling pointer
			     // and can not be freed
		}

	
		write(1, a, b - a); // when "b" is incremented away from "a" and
				    // becomes a dangling pointer then we can
				    // calculate the length of the object as b-a.

		free(a); // "a" however points at the original
			 // location that "b" pointed to and
			 // can be used to free the memory
		return 0; 
	}




























-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Function pointers 8.0) 			                 page 9

Function pointers make objects even more powerful by allowing them to have
functions assigned to their members. Effectively they take the struct which is 
data and the function (which has functionality) and combines them. Thus allowing
the object itself to perform actions.


	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h> 

	typedef struct{ 
	        char *rp;
		size_t len;
		int (*f)(int, int);
	} object;

	int add(int x, int y)
	{
		return x+y;
	}

	int mul(int x, int y)
	{
		return x*y;
	}

	object *object_init(object *o, int (*func)(int x, int y))
	{
		o->f = func;
		return o;
	}

	object *object_exec(object *o, int x, int y)
	{ 
		printf( "%d\n",  o->f(x, y));
		return o;
	}

	int main(void)
	{ 
		object *o = malloc(sizeof(object));

		o = object_init(o, add);

		o = object_exec(o, 2, 3);

		o = object_init(o, mul);

		o = object_exec(o, 2, 3);

			/* or */

		printf( "%d\n",  o->f(3, 3));

		free(o);

		return 0;
	}








-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Function pointers (arrays of) 8.1) 		                page 10

The concept of function pointers can be extended to an array of function
pointers within an object. By also including an "iterator" function we can
effectively add functions into the array one at a time and then execute them
all at once with the iterator function. The initializer function is left
separate and functions are added with the obj_addaction function. Presented
below is a program that demonstrates how to create a powerful object using an 
array of function pointers

	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h> 

	typedef struct object object;

	object *iterate(object *o);

	typedef struct object{ 
	        char *rp;
		size_t len;
		size_t actions;
		object *(*iterate)(object *o); 
		object *(*f[10])(object *o); 
	} object;

	object *obj_init(object *o)
	{
		o->iterate = iterate;
		o->rp = malloc(256);
		o->len = 0;
		o->actions = 0;
	}

	object *obj_pop(object *o)
	{
		o->len = sprintf(o->rp, "%s\n", "string here");
	}

	object *obj_write(object *o)
	{
		write(1, o->rp, o->len);
	}

	object *obj_addaction(object *o, object *(*f)(object *))
	{
		o->f[o->actions] = f;
		o->actions++;
		return o;
	}

	object *iterate(object *o)
	{
		size_t i = 0;
		for (; i < o->actions;++i) 
			o->f[i](o);
		return o;
	}

	int main(void)
	{ 
		object *o = malloc(sizeof(object));
		o = obj_init(o);
		o = obj_addaction(o, obj_pop);
		o = obj_addaction(o, obj_write);
		o = o->iterate(o);
		return 0;
	}
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Creating dynamic libraries 9.0) 		                page 11

Unlike static libraries, dynamic libraries can not be made using the `ar'
utility and instead must be constructed by supplying directions to the compiler
telling it to create them. Because our dynamic library is not going to be
installed we also have to specify the "-rpath" so that the dynamic loader knows
how to find the executable. Normally with a library that will be installed to
the end target of a system's /lib directory "-rpath" should not be specified.
Another way to do this is to not use "rpath" at all and instead execute the
test binary in place like this `LD_LIBRARY_PATH=$(pwd) ./main'. Presented below
are 5 files that can be put into a directory to create a simple dynamic library
and build system.

Makefile:

	all: 

		# Create the object code
		gcc -c frog.c dog.c swan.c -static
		# Create a dynamic library
		cc -shared -Wl,-soname,libanim.so -o libanim.so frog.o swan.o dog.o
		# And finally link it into our executable test driver "main.c"
		gcc main.c libanim.so -o main "-Wl,-rpath=$(PWD)"

	clean:

		rm frog.o dog.o swan.o libanim.so main


animals.h:

	#ifndef _ANIMALS_
	#define _ANIMALS_

	extern int dogs;
	extern int swans;
	extern int frogs;
	int inc_dogs(int);
	int inc_swans(int);
	int inc_frogs(int);

	#endif

frog.c:
	int frogs = 10;

	int inc_frogs(int d)
	{
		return d + 1;
	}
dog.c:
	int dogs = 10;

	int inc_dogs(int d)
	{
		return d + 1;
	
	}
swan.c:
	int swans = 10;

	int inc_swans(int d)
	{
		return d + 1;
	}

main.c: (next page)

-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Creating dynamic libraries 9.0) 		                page 12

main.c
	#include <stdio.h>
	#include "animals.h"
	int main(void)
	{ 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs);
		dogs = inc_dogs(dogs);
		swans = inc_dogs(swans);
		frogs = inc_dogs(frogs); 
		printf("Number of dogs %d\n", dogs);
		printf("Number of swans %d\n", swans);
		printf("Number of frogs %d\n", frogs); 
		return 0; 
	}


















































-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Simple objects using typedefed structs 10.0)                  page 12


It's possible to program using objects in C without all of the complicated
pointer foo-bar. Here is an example of how to program in C using only simple 
arrays of typedefed structs.


	#include <stdio.h> 
	#include <unistd.h>

	typedef struct{ 
	        char rp[1024];
		size_t len;
	} object; 

	int main(void)
	{ 
		size_t i = 0;
		size_t lim = 10;
		object o[10]; 
	
		for ( ; i < lim ; ++i) 
			(o+i)->len = sprintf((o+i)->rp, "string %zu\n", i); 
	
		for (i=0 ; i < lim ; ++i)
			write(1, (o+i)->rp, (o+i)->len); 

		return 0; 
	}






































-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Unix pipelines (for a simple shell) 11.0)                     page 13

Unix pipelines can be created between utilities without using a buffer of any
kind. Using the typical object it becomes simple to store the information 
needed to seamlessly connect the stdin and stdout of a series of utilities.
Pipe() is not set up for the final command in the sequence. Presented below is
a small program that demonstrates the basics needed for writing a simple shell
that supports arbitrary numbers of pipes. The sequence used is equivalent to
"ls -l | wc -l | wc -l | wc -l | wc -l ..."

	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h>
	#include <sys/types.h>
	#include <sys/wait.h>

	typedef struct{
		char *cmd[3];	/* command vector */
		int in;		/* stdin */
		int out;	/* stdout */
		pid_t pids;	/* for waitpid() */
		int err;	/* for waitpid() */
		int piped;	/* boolean value */
	} object;

	int main(void)
	{ 
		int fildes[2];
		size_t lim = 10;
		size_t i = 0;
		object o[10];
		object *p = o;
	
		for(i=0;i<lim;++i, ++p) /* set all cmd vectors to "wc -l" */
		{
			p->cmd[0] = "wc";
			p->cmd[1] = "-l";
			p->cmd[2] = NULL;
			p->out = p->in = -1;
			p->piped = 1;
		}
		o->cmd[0] = "ls"; /* reset the first cmd vector to "ls -la" */
		(p-1)->piped = 0; /* the final command is not piped */
		p = o;
	
		for(i=0;i<lim;++i, ++p)
		{ 
			if (p->piped == 1)
			{
       	        		pipe(fildes);
				(p+1)->in = fildes[0];
				(p)->out = fildes[1];
			}
			if ((p->pids = fork()) == 0)
			{ 
				dup2(p->in, STDIN_FILENO); 
        			dup2(p->out, STDOUT_FILENO);
				execvp(p->cmd[0], (o+i)->cmd); 
				_exit(1); 
			} 
			waitpid(p->pids, &(p->err), 0);
			if (p->out != -1)
                		close(p->out);
			if (p->in != -1)
	       	       		close(p->in);
		} 
		return 0; 
	}
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Unsigned pow 12.0 (base^cardinality))                         page 14


The total number of values possible within a given range in base N within a set
with a cardinality of C can be expressed as (N^C).

N=2
C=4

scientfic
notation   decimal    binary

2^4    =   16    =    0000 (1)  0100 (5)  1000 (9)   1100 (13)
                      0001 (2)  0101 (6)  1001 (10)  1101 (14)
                      0010 (3)  0110 (7)  1010 (11)  1110 (15)
                      0011 (4)  0111 (8)  1011 (12)  1111 (16)
                 

Using binary counting it is easy to prove this formula by iterating through all
possible values. In decimal (greater N) or with a greater cardinality (greater 
C) the table of values would be much larger --however the formula for computing
the total amount of unique values the number can hold is the same.

This formula (N^C) allows for fast and logical computation of probabilities in
a non-deterministic setting such as a dice game throwing "random" dice throws.

Here is an explanation of the probability of obtaining the sequence
 4, 6, 2, 5, 7, 9, 8 out of a random throwing of 7 dice: 

6 sided dice use a base 5 counting system consisting of the character values 1-6
(1,2,3,4,5 and 6). Therefore computing the maximum number of possible dice
combinations in base 5 using 7 dice is simple and can be expressed as the value 
5555555 (or 6666666). Therefore the entire range of this number system sits
between 0000000 and 5555555 possibilities in base 5. The possibility of such a
a roll is therefore 1/(5^7).

Normally '^' powers in C are computed using pow() from libm and the math.h
header. However because we are going to use size_t in this case to represent our
counting base pow() itself is unsuitable. The function usign_pow presented below
is sufficient for calculating base*cardinality which is never negative nor
consisting of fractional parts. (support for fractions in pow requires exp and
log and is not covered here).


	#include <stdio.h>

	size_t usign_pow(size_t x, size_t n)
	{
	        size_t y = 1;
	        while (n--)
	              y *= x;
	        return y;
	}

	int main(void)
	{
		size_t base = 2;
		size_t cardinality = 4;
		printf("Total brute range %zu\n", usign_pow(base, cardinality));
		return 0;
	}







-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Singly linked lists (13.0))                                   page 15

Singly linked lists can be created such that the ->next members point in either
direction. The simplest possible singly linked list builds this chain backwards
sometimes leading people to believe that it needs to be reversed. Such reversal
is unneeded as the linked list can be simply created going the opposite
direction. Presented below are the functions forpop and backpop which create a
forward and backward populated linked list respectively.


	#include <stdio.h>
	#include <stdlib.h>

	typedef struct object{ 
		size_t i;
		struct object *next;
	} object;

	object *freeobj(object*);

	void *safe_free(void *a)
	{
	        free(a);
	        return NULL;
	}

	void *verbose_malloc(size_t i)
	{
		void *ret;
		if (!(ret = malloc(i))) 
			perror("malloc error: ");
		return ret;
	}

	object *forpop(object *head, size_t i)
	{
		/* modified linked list shares members forwards */
	        static object *tail = NULL;
	        object *ptr;
		if(!(ptr = verbose_malloc(sizeof(object))))
			return head = freeobj(head);

	        ptr->next = NULL;
	        ptr->i = i;
	        if (!(head))
	                tail = head = ptr;
	        else if (tail){
	                tail->next = ptr;
	                tail = ptr;
	        }
	        return head;
	}

	object *backpop(object *head, size_t i)
	{
		/* simple linked list shares members backwards */
		object* o;
		if (!(o = verbose_malloc(sizeof(object))))
			return head = freeobj(head);
		o->i = i;
		o->next = head;
		return o;
	}

	void iterate(object* head)
	{
		object *o;
		for(o = head;o;o = o->next)
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Singly linked lists (13.0 (continued)))                       page 16

			printf("(%zu)-->", o->i); 
		printf("END\n\n");
	}

	object *placefreeobj(object *hold)
	{
		if (hold)
	        {
	                printf("free(%zu)-->", hold->i);
	                hold = safe_free(hold);
	        }
		return hold;
	}

	object *freeobj(object *head)
	{
	        object *o;
		object *hold = NULL;
	        for(o = head;o;o = o->next)
		{
			hold = placefreeobj(hold);
			hold = o; 
		}
		hold = placefreeobj(hold);
	
		if (o == head)
			printf("Nothing to be freed  ");
	        printf("END\n\n");
		return hold;
	}

	int main(void)
	{ 
		size_t i;
		object* head = NULL; 
		for(i = 0; i<=20; i++) 
			if (!(head = forpop(head, i)))
				return 1;
	
		iterate(head);
		head = freeobj(head);
	
		for(i = 0; i<=20; i++) 
			if (!(head = backpop(head, i)))
				return 1;
	
		iterate(head);
		head = freeobj(head);

		return 0;
	}















-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Safe reallocation)                                            page 17

There are very few tricks that universally apply to all C memory management. By
using the idiom of passing the value of a pointer to a pointer to a type to a
wrapper for free, realloc and malloc however, one can force a number of useful
scenarios. One such scenario is to take advantage of the C standard's specified
behavior for realloc; "If memory for the new object cannot be allocated, the 
old object is not deallocated and its value is unchanged" in the C11 draft.
We can therefore reduce this operation to a single line of code using a wrapper
function. Similarly, all freed memory can be explicitly made to point to NULL
. Malloc in this case performs no special function but is wrapped in the same
way as free and realloc in order to present a consistent API.

	#include <stdio.h>
	#include <stdlib.h>

	int safe_free(void **a)
	{ 
		free(*a);
		*a = NULL;
		return 1;
	}

	int safe_realloc(void **a, size_t i)
	{
		void *tmp;
		if (!(tmp = realloc(*a, i)))
		{
			perror("Realloc error: ");
			return -1;
		}
		*a = tmp;
		return 1;
	}

	int safe_malloc(void **a, size_t i)
	{ 
	        if (!(*a = malloc(i)))
	        {
	                perror("Malloc error: ");
	                return -1;
	        }
		return 1;
	}

	int main(void)
	{
		char *a;
		size_t i = 0;
		if (!(safe_malloc((void**)&a, 1)))
			return 1; 
		if (!(safe_realloc((void**)&a, 10)))
			return 1; 
		if (a)
			printf("a  exists\n"); 
		for (i=0;i < 10;++i)
			a[i];
		printf("First reallocation successful\n");
		if (!(safe_realloc((void**)&a, (size_t)-1))) // will fail
			;//return 1
		if (a) printf("a  exists\n");
		for (i=0;i < 10;++i)
			a[i];
		printf("Second reallocation left the pointer unchanged\n");
		if(!(safe_free((void**)&a)))
			;// NULL pointers passed to free indicate design flaw 
		return 0;
	}
-------------------------------------------------------------------------------
-------------------------------------------------------------------------------

