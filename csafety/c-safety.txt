c-safety (programming with abstract objects)			page 1

The C standard identifies objects in a very broad sense and applies the
term to "any object in memory". However this definition of object does
not address the power that C has to create and use objects in a modern
sense of it being the primary predecessor to "object oriented
programing".

Presented below is a method of "programming with objects" in C.




	#include <stdlib.h>
	#include <stdio.h> 
	#include <unistd.h>

	typedef struct{ 
	        char *rp; 
		size_t len;
	} object; 

	int main(void)
	{ 
		size_t i = 0;
		size_t lim = 10;

		/* create an array of objects */
		object *o = malloc(sizeof(object) * lim); 

		/* 
			allocate memory for and populate the 
			members of the array of objects 
		*/

		for ( ; i < lim ; ++i)
		{
			(o+i)->rp = malloc(sizeof(char) * 100);
			(o+i)->len = sprintf((o+i)->rp, "string %zu\n", i); 
		} 
	
		/* test the array of objects (fast write!) */
		for (i=0 ; i < lim ; ++i)
			write(1, (o+i)->rp, (o+i)->len);
	
		/* free the objects' member memory allocations */
		for (i=0 ; i < lim ; ++i)
       	         free((o+i)->rp);
	
		/* free the object */
		free(o);
	
		return 0; 
	}















-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Pass by address of a pointer to a pointer)   	                page 2


C does not support "pass by reference" nonetheless by passing the value
of an address to a function which accepts a pointer to a pointer to a 
type we can modify a value in C similar to C++'s "pass by reference". 
The canonical example of this is getline() from the C standard library.

Presented below is the function pass_bappt() (Pass by address of a
pointer to a pointer to a type).



	#include <stdlib.h>
	#include <stdio.h>
	typedef struct{ 
	        char *rp; 
		size_t len; /* len is not used in this example */
	} object;

	void does_not_work(char *a) 
	{
		/* Doesn't work! (obviously) */
		a = "Does not work!";
	}

	void pass_bappt(char **a) 
	{ 
		/*
			"Pass by value of an address of a pointer to a pointer to a 
			 type (pass_baapt)"
		*/
		*a = "hello world";
	}

	int main(void)
	{ 
		object *o;
		o = malloc(sizeof(object)); 
	
		o->rp = "This pointer to a string literal should be overwritten\n";
	
     		printf("%s\n", o->rp);

	        pass_bappt(&(o->rp)); /* note the '&' */
   
    		printf("%s\n", o->rp);
     
      		does_not_work(o->rp);  /* Doesn't work! (obviously) */
	
		printf("%s\n", o->rp);
	

		free(o);
		return 0; 
	}












-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Prevent double frees)   	              			page 3


The C11 draft states "If ptr is a null pointer, no action occurs."
therefore preventing "double frees" is reduced to the simple
operation of explicitly setting deallocated variables to NULL.  


	#include <stdlib.h>
	#include <stdio.h> 

	typedef struct{ 
	        char *rp; 
		size_t len;
	}object;

	void *safe_free(void *a) 
	{ 
		free(a); 
		return NULL; 
	}

	int main(void)
	{
		char *l; 
		object *o;
		o = malloc(sizeof(object));
		o->rp = malloc(1000); 
		o->rp = safe_free(o->rp);
		o->rp = safe_free(o->rp); // does nothing
		o = safe_free(o);
		o = safe_free(o); // does nothing

		return 0; 
	}

































-------------------------------------------------------------------------------
------------------------------------------------------------------------------- 
c-safety (Opaque objects and pointers)                                   page 4

This program attempts to use the opaque-objects we have created.
It has the ability to access and use the type "object" but not its
structure members. The opaque object can only be manipulated via
its API. Which in this case are the simple functions object_init ..
and so on.

main.c:
	#include "shared.h"
	int main(void)
	{
		object *o;
		o = object_init(o);
		object_populate(o, "This is a string\n");
		object_write(o);
		object_free(o);

		//o->rp = "hello";  //<-- This will fail to compile if it is a truly opaque type,
				    // producing the error: "dereferencing pointer to incomplete
			            // type â€˜object {aka struct object}" thus proving that the 
				    // implementation details are indeed hidden from the user of 
				    // the API. Uncomment it to verify
		return 0;
	}


Makefile:
	all:

		gcc -c opaque.c -o opaque.o
		gcc main-driver.c opaque.o -o main-driver

	clean:

		rm *.o
		rm main-driver



This is the actual opaque API library implementation. We declare an
instantiation of the primary API structure from "shared.h" our shared
header. But in this version we actually define its members. Inside of
this file we can access all of the members of our opaque type but the
end user of the API, or indeed anyone outside of this file can not.
However, they can use the library as a library of opaque objects. The
canonical example of the opaque object in C is the FILE * structure
from stdio.  


opaque.c
	#include <stdlib.h>
	#include <stdio.h>
	#include <unistd.h>
	#include <string.h>
	#include "shared.h"


	struct object {
		char *rp;
		size_t len;
	}; 






-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
c-safety (Opaque objects and pointers)                                   page 5

opaque.c (continued):
	size_t object_size(void)
	{
		return sizeof(object);
	}

	object *object_init(object *o)
	{
		o = malloc (object_size());
		o->len = 0;
		return o;
	}

	object *object_populate(object *o, char *s)
	{
		o->rp = s;
		o->len = strlen(s);
	}

	void object_free(object *o)
	{ 
		free(o);
	}

	void object_write(object *o)
	{
		write(1, o->rp, o->len);
	}


shared.h:
	#include <stddef.h>

	typedef struct object object; 
	size_t object_size(void); 
	object *object_init(object *);
	object *object_populate(object *, char *);
	void object_write(object *);
	void object_free(object *);



























-------------------------------------------------------------------------------
-------------------------------------------------------------------------------
