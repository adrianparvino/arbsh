Arbitrary Precision Mathematics Library



BUILDING:
---------

	cd arbprec
	make 


TESTING:
--------

	Run the test binary:

		./tests/test-arbitrary-precision 988983483.14891487417128 908408.38034834834857345834 10 100


API:
----

	Example API usage for dividing two numbers:

	#include <stdio.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <string.h>
	#include <arbprec/arbprec.h>

	int main(int argc, char **argv)
	{
		scale = 80;
		if ( argc < 3 )
			arbprec_die("Needs 2 args\n");

		bigflt *a = str_to_bigflt(argv[1]);
		bigflt *b = str_to_bigflt(argv[2]);

		a = arbprec_add_precision(a, scale);
		arbprec_match_precision(a, b);
		bigflt *c = arbprec_expand_vector(NULL, a->len + b->len);
		
		c = arbprec_div(a, b, c);
		arbprec_print(c);

		arba_free(a);
		arba_free(b);
		arba_free(c);
		return 0;
	} 

	If the example is named "example.c" and arbprec is not installed on 
	your machine compile it with:

		gcc -I./include example.c -L. -larbprec
	
	See tests/arba_arith.c for another example on how to use the API. 


REFERENCES:
-----------

	https://gmplib.org/manual/Division-Algorithms.html#Division-Algorithms

	http://personal.maths.surrey.ac.uk/st/H.Bruin/MMath/Cardinality.html

	https://gmplib.org/manual/Karatsuba-Multiplication.html#Karatsuba-Multiplication

	https://gmplib.org/manual/Multiplication-Algorithms.html#Multiplication-Algorithms

	http://www.cs.utsa.edu/~wagner/CS3343/newton/division.html

	http://mathworld.wolfram.com/NewtonsIteration.html

	An RFC about base64 encoding:

	http://www.rfc-editor.org/rfc/rfc4648.txt

	See Knuth Vol 2. p237. for a division routine that may be faster.

	http://www.cs.utsa.edu/~wagner/CS3343/newton/division.html

        https://en.wikipedia.org/wiki/Division_algorithm#Newton.E2.80.93Raphson_division

        https://stackoverflow.com/questions/9939322/fast-1-x-division-reciprocal

        http://www.jamesbrennan.org/algebra/numbers/real_number_system.htm

        pubs.opengroup.org/onlinepubs/9699919799/utilities/bc.html#top

        https://en.wikipedia.org/wiki/Karatsuba_algorithm

        this site loads too slow, i have not viewed it yet:
        http://www.codewithc.com/c-program-for-newton-raphson-method/


        https://stackoverflow.com/questions/2661541/picking-good-first-estimates-for-goldschmidt-division


CONTACT:
--------

	cm0graff@gmail.com


STYLE:
------

	conditionals:
		if (a > b)
		{
		}

	loops:
		while (a > b)
		{
		}

		for (i=0;a > b;++i)
		{
		}

	functions:
		type *function(type *a, type b);

		if (function(a))
		{
		}

	
// The division algorithm needs a large hardware type such as int in order to
// hold carried values.  The multiplication algorithm uses "partial carries"
// so it will work with extremely small types such as char.  As far as I know,
// no "partial carry" system has been invented for long division.
//
// The subtraction and addition algorithms are implemented using basic long
// hand techniques.  The `place' function provides an offset mechanism which
// determines the radix position and coordinates the left and right hand
// sides.  These algorithms have very small carries which will fit into type
// char.
//
// All bases are supported.  Bases above base 10 are evaluated from ascii
// by the arb_highbase function.  They are represented as 0-9,a-z,A-Z,+,/,= up
// to base 65. Bases higher than 65 default to their cooresponding character set
// values.
//
// Known bugs: non-meaningful zeros are acculumated to the far left of the 
// number with subtraction and multiplication.  However, these are likely easy to
// remedy because they do not interfere with the radix placement precomputations.
// This bug has no effect on the accuracy of the solution but does affect the
// "scale" rendering the "scale" metric useless.

/*
	"[...] on high-precision numbers can now be done using the simple 
	addition, subtraction, multiplication, and long-division procedures 
	we are taught in elementary school.  In fact, most of the algorithms 
	[...] are essentially nothing more than mechanizations of familiar 
	pencil-and-paper operations." 
		(Knuth, "The Art of Computer Programming Vol 2", p. 251)
*

// For subtraction of unknown numbers I used the technique described in Knuth's
// exercise 12. (detect the presence of a left over borrow)
/*
	"Alg[...] S assumes that we know which of the two input operands is the
	larger; if this information is not known, we could go ahead and 
	perform the subtraction anyway, and we would find that an extra 
	“borrow” is still present at the end of the algorithm."
		(Knuth, "The Art of Computer Programming Vol 2", p. 266)
*/

// Zeros are not exactly real numbers. They are in fact place holders that allow
// increases of magnitude. This concept was known to the ancient mayans and in 
// order to creat numbers of varying magnitude they used a symbol that looks
// somwhat like a turtle shell. It is not known what this symbol is derived
// from, but its form is completely different than the other Mayan number
// representations. When I first started writing this arbitrary precision
// library in the winter of 2016 I could not find an example on the web or 
// anywhere for implementing long divison in C. Indeed it is rather tricky
// and not many examples exist. So I set out to whiteboard my own computer
// friendly version. I quickly realized that zero was behaving differently
// as it was not a number at all. My girlfriend who is from Peru was
// studying a series of Aztec codecs for her PhD thesis, which documented the
// Aztec fiscal accounting system. They are some of the most disturbing
// works I have ever seem. I decided to follow her lead and I eventually
// solved the problem of zero not being a real number by simply representing
// it as a "place" or more specifically at the time a Mayan zero shell. In my
// opinion a turtle shell, Armed with this abstraction I quickly overcame the
// problem and wrote my long hand division algorithm. This algorithm is quite
// a bit different that Knuthian long division algorithm D
// however it is dead simple, faster than naive "chunking" and absolutely
// precise. Out of respect for the Mayans and what they accomplished I leave
// this writing here. Zeros inside of arbprec are for this reason _not_ Western
// zeros made by the great early Islamic scholars. 
// All Graff zeros are Mayan zeros.



References:


	Useful web sites:

	http://www.cs.utsa.edu/~wagner/CS3343/newton/division.html

	https://en.wikipedia.org/wiki/Division_algorithm#Newton.E2.80.93Raphson_division

	https://stackoverflow.com/questions/9939322/fast-1-x-division-reciprocal

	http://www.jamesbrennan.org/algebra/numbers/real_number_system.htm

	pubs.opengroup.org/onlinepubs/9699919799/utilities/bc.html#top

	https://en.wikipedia.org/wiki/Karatsuba_algorithm

	this site loads too slow, i have not viewed it yet:
	http://www.codewithc.com/c-program-for-newton-raphson-method/


	https://stackoverflow.com/questions/2661541/picking-good-first-estimates-for-goldschmidt-division

	https://stackoverflow.com/questions/32942466/what-algorithm-should-i-use-for-high-performance-large-integer-division

	https://gmplib.org/manual/Divide-and-Conquer-Division.html#Divide-and-Conquer-Division

	https://gmplib.org/manual/Karatsuba-Multiplication.html#Karatsuba-Multiplication
